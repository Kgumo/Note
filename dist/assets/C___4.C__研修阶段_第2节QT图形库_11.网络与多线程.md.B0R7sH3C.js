import{_ as s,c as a,o as i,a3 as e}from"./chunks/framework.CkaDlzKP.js";const c=JSON.parse('{"title":"网络与多线程","description":"","frontmatter":{},"headers":[],"relativePath":"C++/4.C++研修阶段/第2节QT图形库/11.网络与多线程.md","filePath":"C++/4.C++研修阶段/第2节QT图形库/11.网络与多线程.md","lastUpdated":1754900608000}'),n={name:"C++/4.C++研修阶段/第2节QT图形库/11.网络与多线程.md"};function r(l,t,d,h,p,o){return i(),a("div",null,t[0]||(t[0]=[e(`<h1 id="网络与多线程" tabindex="-1">网络与多线程 <a class="header-anchor" href="#网络与多线程" aria-label="Permalink to &quot;网络与多线程&quot;">​</a></h1><h2 id="网络编程" tabindex="-1">网络编程 <a class="header-anchor" href="#网络编程" aria-label="Permalink to &quot;网络编程&quot;">​</a></h2><h3 id="udp编程" tabindex="-1">UDP编程 <a class="header-anchor" href="#udp编程" aria-label="Permalink to &quot;UDP编程&quot;">​</a></h3><h4 id="主要的类有两个" tabindex="-1">主要的类有两个： <a class="header-anchor" href="#主要的类有两个" aria-label="Permalink to &quot;主要的类有两个：&quot;">​</a></h4><ul><li><strong>Qudpsocket</strong></li><li><strong>QNetworkDatagram</strong></li></ul><h3 id="qudpsocket" tabindex="-1">Qudpsocket <a class="header-anchor" href="#qudpsocket" aria-label="Permalink to &quot;Qudpsocket&quot;">​</a></h3><p><strong>Qudpsocket</strong> 表示一个 UDP 的 socket</p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>说明</th><th>对标原生 API</th></tr></thead><tbody><tr><td>bind(const QHostAddress&amp;, quint16)</td><td>方法</td><td>绑定指定的端口号</td><td>bind</td></tr><tr><td>receiveDatagram()</td><td>方法</td><td>返回 QNetworkDatagram，读取一个 UDP 数据报</td><td>recvfrom</td></tr><tr><td>writeDatagram(const QNetworkDatagram&amp;)</td><td>方法</td><td>发送一个 UDP 数据报</td><td>sendto</td></tr><tr><td>readyRead</td><td>信号</td><td>在收到数据并准备就绪后触发</td><td>无 (类似于 IO 多路复用的通知机制)</td></tr></tbody></table><h3 id="qnetworkdatagram" tabindex="-1">QNetworkDatagram <a class="header-anchor" href="#qnetworkdatagram" aria-label="Permalink to &quot;QNetworkDatagram&quot;">​</a></h3><p><strong>QNetworkDatagram</strong> 表示一个 UDP 数据报</p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>说明</th><th>对标原生 API</th></tr></thead><tbody><tr><td>QNetworkDatagram(const QByteArray&amp;, const QHostAddress&amp;, quint16)</td><td>构造函数</td><td>通过 QByteArray、目标 IP 地址、目标端口号构造一个 UDP 数据报（通常用于发送数据）</td><td>无</td></tr><tr><td>data()</td><td>方法</td><td>获取数据报内部特有的数据（返回 QByteArray）</td><td>无</td></tr><tr><td>senderAddress()</td><td>方法</td><td>获取数据报中包含的对端 IP 地址</td><td>无（recvfrom 包含该功能）</td></tr><tr><td>senderPort()</td><td>方法</td><td>获取数据报中包含的对端端口号</td><td>无（recvfrom 包含该功能）</td></tr></tbody></table><h2 id="tcp编程" tabindex="-1">TCP编程 <a class="header-anchor" href="#tcp编程" aria-label="Permalink to &quot;TCP编程&quot;">​</a></h2><p>核心类有两个：</p><ul><li><strong>QTcpServer</strong></li><li><strong>QTcpSocket</strong></li></ul><h3 id="qtcpserver" tabindex="-1">QTcpServer <a class="header-anchor" href="#qtcpserver" aria-label="Permalink to &quot;QTcpServer&quot;">​</a></h3><p><strong>QTcpServer</strong> 用于监听端口和获取客户端连接</p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>说明</th><th>对标原生 API</th></tr></thead><tbody><tr><td>listen(const QHostAddress&amp;, quint16 port)</td><td>方法</td><td>绑定指定的地址和端口号，并开始监听</td><td>bind 和 listen</td></tr><tr><td>nextPendingConnection()</td><td>方法</td><td>获取已建立的 TCP 连接（返回 QTcpSocket 对象，用于与客户端通信）</td><td>accept</td></tr><tr><td>newConnection</td><td>信号</td><td>当新的客户端建立连接后触发</td><td>无（类似于 IO 多路复用中的通知机制）</td></tr></tbody></table><h3 id="qtcpsocket" tabindex="-1">QTcpSocket <a class="header-anchor" href="#qtcpsocket" aria-label="Permalink to &quot;QTcpSocket&quot;">​</a></h3><p><strong>QTcpSocket</strong> 用于客户端和服务器之间的数据交互</p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>说明</th><th>对标原生 API</th></tr></thead><tbody><tr><td>readAll()</td><td>方法</td><td>读取当前接收缓冲区中的所有数据</td><td>read</td></tr><tr><td>write(const QByteArray&amp;)</td><td>方法</td><td>将数据写入 socket</td><td>write</td></tr><tr><td>deleteLater</td><td>方法</td><td>标记 socket 对象为无效（Qt 在下个事件循环中释放该对象）</td><td>无（类似于半自动化的垃圾回收）</td></tr><tr><td>readyRead</td><td>信号</td><td>当数据到达并准备就绪时触发</td><td>无（类似于 IO 多路复用中的通知机制）</td></tr><tr><td>disconnected</td><td>信号</td><td>当连接断开时触发</td><td>无（类似于 IO 多路复用中的通知机制）</td></tr></tbody></table><h2 id="http-client" tabindex="-1">HTTP Client <a class="header-anchor" href="#http-client" aria-label="Permalink to &quot;HTTP Client&quot;">​</a></h2><p>进行 Qt 开发时，与服务器的通信常使用 HTTP 协议：</p><ul><li>通过 HTTP 从服务器获取数据</li><li>通过 HTTP 向服务器提交数据</li></ul><p>核心类是三个：</p><ul><li><strong>QNetworkAccessManager</strong></li><li><strong>QNetworkRequest</strong></li><li><strong>QNetworkReply</strong></li></ul><h3 id="qnetworkaccessmanager" tabindex="-1">QNetworkAccessManager <a class="header-anchor" href="#qnetworkaccessmanager" aria-label="Permalink to &quot;QNetworkAccessManager&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>get(const QNetworkRequest&amp;)</td><td>发起 HTTP GET 请求（返回 QNetworkReply 对象）</td></tr><tr><td>post(const QNetworkRequest&amp;, const QByteArray&amp;)</td><td>发起 HTTP POST 请求（返回 QNetworkReply 对象）</td></tr></tbody></table><h3 id="qnetworkrequest" tabindex="-1">QNetworkRequest <a class="header-anchor" href="#qnetworkrequest" aria-label="Permalink to &quot;QNetworkRequest&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>QNetworkRequest(const QUrl&amp;)</td><td>通过 URL 构造 HTTP 请求</td></tr><tr><td>setHeader(QNetworkRequest::KnownHeaders header, const QVariant &amp;value)</td><td>设置请求头</td></tr></tbody></table><h4 id="请求头取值" tabindex="-1">请求头取值 <a class="header-anchor" href="#请求头取值" aria-label="Permalink to &quot;请求头取值&quot;">​</a></h4><table tabindex="0"><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>ContentTypeHeader</td><td>描述 body 的类型</td></tr><tr><td>ContentLengthHeader</td><td>描述 body 的长度</td></tr><tr><td>LocationHeader</td><td>用于重定向报文中指定重定向地址（响应中使用）</td></tr><tr><td>CookieHeader</td><td>设置 cookie</td></tr><tr><td>UserAgentHeader</td><td>设置 User-Agent</td></tr></tbody></table><h3 id="qnetworkreply" tabindex="-1">QNetworkReply <a class="header-anchor" href="#qnetworkreply" aria-label="Permalink to &quot;QNetworkReply&quot;">​</a></h3><p><strong>QNetworkReply</strong> 表示一个 HTTP 响应（继承自 <code>qroDevice</code>）</p><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>error()</td><td>获取出错状态</td></tr><tr><td>errorString()</td><td>获取出错原因的文本描述</td></tr><tr><td>readAll()</td><td>读取响应 body</td></tr><tr><td>header(QNetworkRequest::KnownHeaders header)</td><td>读取指定响应头的值</td></tr></tbody></table><p><strong>重要信号</strong>：</p><ul><li><strong>finished()</strong>：当客户端收到完整的响应数据后触发</li></ul><hr><h2 id="多线程编程" tabindex="-1">多线程编程 <a class="header-anchor" href="#多线程编程" aria-label="Permalink to &quot;多线程编程&quot;">​</a></h2><h3 id="qthread" tabindex="-1">QThread <a class="header-anchor" href="#qthread" aria-label="Permalink to &quot;QThread&quot;">​</a></h3><p><strong>QThread</strong> 是 Qt 框架中处理多线程编程的类（父类为 <code>QObject</code>），继承了信号槽机制、对象树管理等特性。</p><h4 id="qthread-的特点" tabindex="-1">QThread 的特点 <a class="header-anchor" href="#qthread-的特点" aria-label="Permalink to &quot;QThread 的特点&quot;">​</a></h4><ol><li><p><strong>线程创建和管理</strong></p><ul><li><strong>简单的线程创建</strong>：继承 QThread 并重写 <code>run()</code> 函数（线程入口点）</li><li><strong>生命周期管理</strong>： <ul><li><code>start()</code>：启动线程</li><li><code>quit()</code>：优雅地请求线程退出</li><li><code>terminate()</code>：强制终止线程（可能导致资源泄漏，尽量避免使用）</li></ul></li></ul></li><li><p><strong>信号和槽机制在线程中的应用</strong></p><ul><li><strong>线程间通信</strong>：通过信号槽实现跨线程通信（例如任务完成时通知主线程）</li><li><strong>异步操作</strong>：在后台线程执行耗时任务，通过信号返回结果</li></ul></li><li><p><strong>资源管理</strong></p><ul><li><strong>对象树机制</strong>：QThread 参与 Qt 对象树管理（父对象销毁时自动清理）</li><li><strong>线程局部存储</strong>：通过 <code>threadLocalStorage()</code> 安全访问线程局部变量</li></ul></li><li><p><strong>可重入性和线程安全性</strong></p><ul><li><strong>可重入函数</strong>：QThread 的非静态成员函数可被多线程同时调用（不访问共享数据时）</li><li><strong>线程安全的操作</strong>：内部同步处理确保启动/停止线程的正确性</li></ul></li></ol><h4 id="常用-api" tabindex="-1">常用 API <a class="header-anchor" href="#常用-api" aria-label="Permalink to &quot;常用 API&quot;">​</a></h4><table tabindex="0"><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>run()</td><td>线程入口函数（需重写）</td></tr><tr><td>start()</td><td>调用 run() 启动线程（若线程已在运行则无效）</td></tr><tr><td>currentThread()</td><td>返回管理当前线程的 QThread 指针</td></tr><tr><td>isRunning()</td><td>线程运行时返回 true</td></tr><tr><td>sleep()/msleep()/usleep()</td><td>使线程休眠（秒/毫秒/微秒）</td></tr><tr><td>wait()</td><td>阻塞线程直至：1. 线程执行完成 2. 超时（默认 ULONG_MAX 永不超时）</td></tr><tr><td>terminate()</td><td>强制终止线程（需谨慎使用）</td></tr><tr><td>finished()</td><td>信号：线程结束时触发（用于清理工作）</td></tr></tbody></table><h4 id="使用步骤" tabindex="-1">使用步骤 <a class="header-anchor" href="#使用步骤" aria-label="Permalink to &quot;使用步骤&quot;">​</a></h4><ol><li>自定义类继承 QThread</li><li>重写 <code>run()</code> 函数（包含需执行的复杂逻辑）</li><li><strong>启动线程</strong>：调用 <code>start()</code>（非直接调用 <code>run()</code>）</li><li>通过信号通知主线程任务完成</li><li>关闭线程</li></ol><h4 id="多线程使用事项" tabindex="-1">多线程使用事项 <a class="header-anchor" href="#多线程使用事项" aria-label="Permalink to &quot;多线程使用事项&quot;">​</a></h4><ul><li><strong>禁止在线程函数中操作 UI</strong>： <ul><li><strong>原因1（线程安全性）</strong>：UI 操作应由主线程管理（GUI 框架非线程安全）</li><li><strong>原因2（事件循环机制）</strong>：跨线程操作 UI 会干扰主线程事件循环（导致界面异常）</li></ul></li><li><strong><code>connect()</code> 的第五参数 <code>Qt::ConnectionType</code></strong>：<table tabindex="0"><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td>Qt::AutoConnection</td><td>自动选择（同线程用 Direct，跨线程用 Queued）</td></tr><tr><td>Qt::DirectConnection</td><td>信号发出后槽函数立即在同一线程执行（需确保线程安全）</td></tr><tr><td>Qt::QueuedConnection</td><td>槽函数插入接收者线程事件队列（跨线程安全）</td></tr><tr><td>Qt::BlockingQueuedConnection</td><td>发送线程阻塞直至槽函数执行完毕（注意死锁风险）</td></tr><tr><td>Qt::UniqueConnection</td><td>标志位（可与其他类型组合，确保唯一连接）</td></tr></tbody></table></li></ul><h3 id="线程安全" tabindex="-1">线程安全 <a class="header-anchor" href="#线程安全" aria-label="Permalink to &quot;线程安全&quot;">​</a></h3><p>常用同步类：</p><ul><li><strong>互斥锁</strong>：QMutex、QMutexLocker</li><li><strong>条件变量</strong>：QWaitCondition</li><li><strong>信号量</strong>：QSemaphore</li><li><strong>读写锁</strong>：QReadLocker、QWriteLocker、QReadWriteLock</li></ul><h4 id="互斥锁" tabindex="-1">互斥锁 <a class="header-anchor" href="#互斥锁" aria-label="Permalink to &quot;互斥锁&quot;">​</a></h4><p><strong>QMutex</strong></p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QMutex mutex;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 上锁</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问共享资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 解锁</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>QMutexLocker</strong>（RAII 方式管理锁）</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QMutex mutex;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QMutexLocker </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">locker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 自动上锁</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 访问共享资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 作用域结束自动解锁</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="读写锁" tabindex="-1">读写锁 <a class="header-anchor" href="#读写锁" aria-label="Permalink to &quot;读写锁&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QReadWriteLock rwLock;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 读操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QReadLocker </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">locker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rwLock);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 上读锁（允许多线程读）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 读取共享资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 写操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QWriteLocker </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">locker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rwLock);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 上写锁（独占访问）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 修改共享资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="条件变量" tabindex="-1">条件变量 <a class="header-anchor" href="#条件变量" aria-label="Permalink to &quot;条件变量&quot;">​</a></h4><p><strong>QWaitCondition</strong></p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QMutex mutex;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QWaitCondition condition;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等待线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">conditionFullfilled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    condition.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 释放锁并等待</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 条件满足后继续执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通知线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changeCondition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">condition.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wakeAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 唤醒所有等待线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mutex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h4 id="信号量" tabindex="-1">信号量 <a class="header-anchor" href="#信号量" aria-label="Permalink to &quot;信号量&quot;">​</a></h4><p><strong>QSemaphore</strong></p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QSemaphore</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> semaphore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 允许2个线程并发访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">semaphore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">acquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 获取信号量（资源不足时阻塞）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问共享资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">semaphore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 释放信号量</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h2 id="作业" tabindex="-1">作业 <a class="header-anchor" href="#作业" aria-label="Permalink to &quot;作业&quot;">​</a></h2><p>完成聊天软件的网络部分</p>`,67)]))}const g=s(n,[["render",r]]);export{c as __pageData,g as default};
