import{_ as i,c as r,o as a,a3 as o}from"./chunks/framework.C8Xs1bna.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"C++/3.C++进阶课程/第2节数据结构与基本算法/14.基础算法.md","filePath":"C++/3.C++进阶课程/第2节数据结构与基本算法/14.基础算法.md","lastUpdated":1754900608000}'),t={name:"C++/3.C++进阶课程/第2节数据结构与基本算法/14.基础算法.md"};function n(e,l,s,u,h,g){return a(),r("div",null,l[0]||(l[0]=[o('<h3 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h3><p>排序是最基本的算法之一。</p><h4 id="十大经典排序算法" tabindex="-1">十大经典排序算法 <a class="header-anchor" href="#十大经典排序算法" aria-label="Permalink to &quot;十大经典排序算法&quot;">​</a></h4><ol><li>插入排序</li><li>冒泡排序</li><li>选择排序</li><li>希尔排序</li><li>计数排序</li><li>基数排序</li><li>快速排序</li><li>归并排序</li><li>桶排序</li><li>堆排序</li></ol><hr><h3 id="关于时间复杂度" tabindex="-1">关于时间复杂度 <a class="header-anchor" href="#关于时间复杂度" aria-label="Permalink to &quot;关于时间复杂度&quot;">​</a></h3><h4 id="计算方式" tabindex="-1">计算方式 <a class="header-anchor" href="#计算方式" aria-label="Permalink to &quot;计算方式&quot;">​</a></h4><ul><li>时间（空间）复杂度的计算公式：( T(n) = O(f(n)) ) <ul><li>( T(n) )：代码执行的时间</li><li>( f(n) )：每一行代码执行次数的总和（通常只关注量级最大的项，忽略低阶、常数和系数） <ul><li>若 ( f(n) = 2n^2 + 2n + 3 )，则 ( T(n) = O(n^2) )</li></ul></li><li>( n )：数据规模</li></ul></li></ul><h4 id="常见复杂度量级" tabindex="-1">常见复杂度量级 <a class="header-anchor" href="#常见复杂度量级" aria-label="Permalink to &quot;常见复杂度量级&quot;">​</a></h4><ol><li><strong>常数阶</strong>：( O(1) ) <ul><li>执行时间不随数据规模变化</li></ul></li><li><strong>对数阶</strong>：( O(\\log n) ) <ul><li>搜索空间每次缩小一半，关键操作次数约 ( \\log_2 n )</li></ul></li><li><strong>线性阶</strong>：( O(n) ) <ul><li>执行时间与数据规模成正比</li></ul></li><li><strong>线性对数阶</strong>：( O(n \\log n) )</li><li><strong>k次方阶</strong>：( O(n^k) )</li><li><strong>指数阶</strong>：( O(2^n) )</li><li><strong>阶乘阶</strong>：( O(n!) )</li></ol><hr><h3 id="桶排序" tabindex="-1">桶排序 <a class="header-anchor" href="#桶排序" aria-label="Permalink to &quot;桶排序&quot;">​</a></h3><p>桶排序是一种将待排序数据分配到多个&quot;桶&quot;中，对每个桶单独排序，最后合并结果的算法。<br><strong>适用场景</strong>：数据分布均匀且范围有限的情况。</p><h4 id="算法步骤" tabindex="-1">算法步骤 <a class="header-anchor" href="#算法步骤" aria-label="Permalink to &quot;算法步骤&quot;">​</a></h4><ol><li><strong>确定桶的数量和大小</strong><ul><li>根据数据范围和分布设定桶（如数据范围0~100，可设10个桶，每个桶负责10个数据）。</li></ul></li><li><strong>分配数据到桶</strong><ul><li>遍历数据，将每个元素放入对应的桶。</li></ul></li><li><strong>桶内排序</strong><ul><li>对每个桶中的元素排序（可使用任意排序算法）。</li></ul></li><li><strong>合并结果</strong><ul><li>将所有桶的有序数据按顺序合并。</li></ul></li></ol><hr><h3 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h3><p>快速排序是一种分治算法，通过递归划分数组实现排序。</p><h4 id="算法步骤-1" tabindex="-1">算法步骤 <a class="header-anchor" href="#算法步骤-1" aria-label="Permalink to &quot;算法步骤&quot;">​</a></h4><ol><li><strong>选择基准元素（pivot）</strong><ul><li>从数组中任选一元素（通常选首元素、尾元素或中间元素）。</li></ul></li><li><strong>分区（Partitioning）</strong><ul><li>重排数组： <ul><li>所有小于基准的元素移到基准左侧。</li><li>所有大于基准的元素移到基准右侧。</li></ul></li></ul></li><li><strong>递归排序</strong><ul><li>对左侧子数组和右侧子数组递归执行快速排序。</li></ul></li><li><strong>合并结果</strong><ul><li>由于是原地排序，无需额外合并步骤。</li></ul></li></ol><h4 id="示例过程" tabindex="-1">示例过程 <a class="header-anchor" href="#示例过程" aria-label="Permalink to &quot;示例过程&quot;">​</a></h4><p><strong>初始数组</strong>：<br> [ 10, , 3, , 5, , 7, , 1, , 6, , 4, , 2, , 8, , 9 ]</p><p><strong>分区操作</strong>：</p><ul><li>基准选10 → 分区后：[ 3, \\, 5, \\, 7, \\, 1, \\, 6, \\, 4, \\, 2, \\, 8, \\, 9, \\, \\textcolor{red}{10} ] </li><li>左侧子数组递归（基准选3）：[ 1, \\, 2, \\, \\textcolor{red}{3}, \\, 5, \\, 7, \\, 6, \\, 4, \\, 8, \\, 9 ] </li><li>右侧子数组递归（基准选5）：[ 4, \\, \\textcolor{red}{5}, \\, 7, \\, 6, \\, 8, \\, 9 ] </li><li>最终有序数组：<br> [ 1, , 2, , 3, , 4, , 5, , 6, , 7, , 8, , 9, , 10 ]</li></ul><hr><h3 id="作业" tabindex="-1">作业 <a class="header-anchor" href="#作业" aria-label="Permalink to &quot;作业&quot;">​</a></h3><p>封装一个数据结构库（<code>DatastructureLibrarys</code>），包含以下内容：</p><ol><li><strong>基础数据结构</strong>： <ul><li>链表</li><li>栈</li><li>队列</li><li>优先队列</li><li>二叉树（二叉排序树/平衡二叉树）</li><li>图</li></ul></li><li><strong>排序算法</strong>： <ul><li>实现十大经典排序算法（如桶排序、快速排序等）。</li></ul></li></ol><hr><p><strong>总结</strong>：</p><ul><li><strong>桶排序</strong>：适合均匀分布数据，分桶后排序合并。</li><li><strong>快速排序</strong>：高效分治策略，平均复杂度 ( O(n \\log n) )。</li><li><strong>时间复杂度</strong>：是算法性能的核心指标，需根据场景选择合适的排序算法。</li></ul>',31)]))}const _=i(t,[["render",n]]);export{c as __pageData,_ as default};
