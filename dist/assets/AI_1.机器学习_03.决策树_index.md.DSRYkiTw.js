import{_ as a,c as e,o as n,a4 as t}from"./chunks/framework.BQlL4Ck5.js";const d=JSON.parse('{"title":"决策树学习基础","description":"","frontmatter":{},"headers":[],"relativePath":"AI/1.机器学习/03.决策树/index.md","filePath":"AI/1.机器学习/03.决策树/index.md","lastUpdated":1754871536000}'),l={name:"AI/1.机器学习/03.决策树/index.md"};function i(r,s,p,m,o,c){return n(),e("div",null,s[0]||(s[0]=[t('<h1 id="决策树学习基础" tabindex="-1">决策树学习基础 <a class="header-anchor" href="#决策树学习基础" aria-label="Permalink to &quot;决策树学习基础&quot;">​</a></h1><h2 id="_1-决策树概述" tabindex="-1">1. 决策树概述 <a class="header-anchor" href="#_1-决策树概述" aria-label="Permalink to &quot;1. 决策树概述&quot;">​</a></h2><p>决策树是一种常用的机器学习方法，特别适用于带有非数值特征的分类问题。它通过一系列规则对数据进行分割，形成树状结构，最终做出决策。</p><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li>带有非数值特征的分类问题</li><li>离散特征（如颜色、大小等类别型数据）</li><li>特征间没有明确的相似度概念</li><li>特征无序的情况</li></ul><p><strong>示例</strong>：判断水果类型</p><ul><li>颜色：红色、绿色、黄色...</li><li>大小：小、中、大</li><li>形状：球形、细长</li><li>味道：甜、酸</li></ul><h2 id="_2-混杂度-不纯度-度量" tabindex="-1">2. 混杂度(不纯度)度量 <a class="header-anchor" href="#_2-混杂度-不纯度-度量" aria-label="Permalink to &quot;2. 混杂度(不纯度)度量&quot;">​</a></h2><p>决策树构建的核心是选择最佳分割特征，这需要衡量节点的不纯度(混杂度)。主要有三种度量方式：</p><h3 id="_2-1-熵-entropy" tabindex="-1">2.1 熵(Entropy) <a class="header-anchor" href="#_2-1-熵-entropy" aria-label="Permalink to &quot;2.1 熵(Entropy)&quot;">​</a></h3><p>公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo>(</mo><mi>N</mi><mo>)</mo><mo>=</mo><mo>−</mo><msub><mo>∑</mo><mrow><mi>j</mi></mrow></msub><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>w</mi><mrow><mi>j</mi></mrow></msub><mo fence="true">)</mo></mrow><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mi>P</mi><mrow><mo fence="true">(</mo><msub><mi>w</mi><mrow><mi>j</mi></mrow></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">Entropy(N)=-\\sum_{j} P\\left(w_{j}\\right) \\log _{2} P\\left(w_{j}\\right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.050005em;"></span><span class="strut bottom" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord">−</span><span class="mop op-limits"><span class="vlist"><span style="top:1.177669em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-0.000005000000000032756em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">)</span></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="vlist"><span style="top:0.24444em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">)</span></span></span></span></span></span></p><ul><li>表示系统的混乱程度</li><li>当所有类别概率相等时，熵最大</li><li>完全纯净时(只有一类)，熵为0</li></ul><h3 id="_2-2-gini指数" tabindex="-1">2.2 Gini指数 <a class="header-anchor" href="#_2-2-gini指数" aria-label="Permalink to &quot;2.2 Gini指数&quot;">​</a></h3><p>公式：</p> i(N)=\\sum_{i ≠j} P(w_{i}) P(w_{j})=1-\\sum_{j} P^{2}(w_{j}) <ul><li>表示随机抽取两个样本，它们类别不一致的概率</li><li>最大Gini混杂度在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mi>n</mi><mo>∗</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><msup><mo>)</mo><mrow><mn>2</mn></mrow></msup><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">1-n*(1/n)^{2}=1-1/n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mbin">∗</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit">n</span><span class="mclose"><span class="mclose">)</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit">n</span></span></span></span>时取得</li></ul><h3 id="_2-3-错分类率" tabindex="-1">2.3 错分类率 <a class="header-anchor" href="#_2-3-错分类率" aria-label="Permalink to &quot;2.3 错分类率&quot;">​</a></h3><p>公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>(</mo><mi>N</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>max</mi><mrow><mi>j</mi></mrow></msub><mi>P</mi><mo>(</mo><msub><mi>w</mi><mrow><mi>j</mi></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">i(N)=1-\\max _{j} P(w_{j}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.613772em;vertical-align:-0.863772em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mop op-limits"><span class="vlist"><span style="top:0.627664em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:2.7755575615628914e-17em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="mop">max</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></span></p><ul><li>表示节点中最常见类别以外的样本比例</li><li>最大错分类混杂度=最大Gini混杂度=1-1/n</li></ul><h2 id="_3-特征选择方法-id3算法" tabindex="-1">3. 特征选择方法(ID3算法) <a class="header-anchor" href="#_3-特征选择方法-id3算法" aria-label="Permalink to &quot;3. 特征选择方法(ID3算法)&quot;">​</a></h2><p>ID3算法使用信息增益来选择最佳分割特征：</p><ol><li>计算当前节点的熵</li><li>对每个特征，计算按该特征分割后的加权平均熵</li><li>选择使信息增益(原始熵-分割后熵)最大的特征</li></ol><p><strong>信息增益</strong> = 父节点的熵 - 子节点的加权平均熵</p><h2 id="_4-决策树构建过程" tabindex="-1">4. 决策树构建过程 <a class="header-anchor" href="#_4-决策树构建过程" aria-label="Permalink to &quot;4. 决策树构建过程&quot;">​</a></h2><ol><li>从根节点开始，所有训练数据都在根节点</li><li>选择最佳分割特征(如使用ID3算法)</li><li>根据特征值划分数据到子节点</li><li>对每个子节点递归执行上述过程，直到： <ul><li>节点中所有样本属于同一类</li><li>没有剩余特征可用于分割</li><li>达到预定的停止条件(如树深度限制)</li></ul></li></ol><h2 id="_5-决策树的特点" tabindex="-1">5. 决策树的特点 <a class="header-anchor" href="#_5-决策树的特点" aria-label="Permalink to &quot;5. 决策树的特点&quot;">​</a></h2><p><strong>优点</strong>：</p><ul><li>模型直观，易于理解和解释</li><li>能处理数值和类别数据</li><li>不需要数据归一化</li><li>可以处理特征间的交互作用</li></ul><p><strong>缺点</strong>：</p><ul><li>容易过拟合，需要剪枝</li><li>对数据的小变化可能很敏感</li><li>可能创建过于复杂的树</li></ul><h2 id="_6-实际应用示例" tabindex="-1">6. 实际应用示例 <a class="header-anchor" href="#_6-实际应用示例" aria-label="Permalink to &quot;6. 实际应用示例&quot;">​</a></h2><p>文档中提到的&quot;是否可以去享受运动&quot;的例子，决策树可能会考虑以下特征：</p><ul><li>天气(晴、雨、阴)</li><li>温度(高、中、低)</li><li>湿度(高、低)</li><li>风力(强、弱)</li></ul><p>通过构建决策树，可以根据这些特征条件判断某天是否适合户外运动。</p><p>决策树学习是机器学习中基础而重要的方法，理解其原理和各种不纯度度量方式对于正确应用和调优模型至关重要。</p><h1 id="决策树学习进阶" tabindex="-1">决策树学习进阶 <a class="header-anchor" href="#决策树学习进阶" aria-label="Permalink to &quot;决策树学习进阶&quot;">​</a></h1><h2 id="_1-决策树过拟合问题" tabindex="-1">1. 决策树过拟合问题 <a class="header-anchor" href="#_1-决策树过拟合问题" aria-label="Permalink to &quot;1. 决策树过拟合问题&quot;">​</a></h2><h3 id="_1-1-过拟合定义" tabindex="-1">1.1 过拟合定义 <a class="header-anchor" href="#_1-1-过拟合定义" aria-label="Permalink to &quot;1.1 过拟合定义&quot;">​</a></h3><p>在决策树中，我们说假设h∈H对训练集过拟合，如果存在另一个假设h&#39;∈H满足：</p><ul><li>训练误差：err<sub>train</sub>(h) &lt; err<sub>train</sub>(h&#39;)</li><li>测试误差：err<sub>test</sub>(h) &gt; err<sub>test</sub>(h&#39;)</li></ul><h3 id="_1-2-极端过拟合案例" tabindex="-1">1.2 极端过拟合案例 <a class="header-anchor" href="#_1-2-极端过拟合案例" aria-label="Permalink to &quot;1.2 极端过拟合案例&quot;">​</a></h3><ul><li>每个叶节点对应单个训练样本</li><li>整个树相当于数据查表算法的简单实现</li><li>训练准确率100%，但泛化性能极差</li></ul><h2 id="_2-剪枝技术" tabindex="-1">2. 剪枝技术 <a class="header-anchor" href="#_2-剪枝技术" aria-label="Permalink to &quot;2. 剪枝技术&quot;">​</a></h2><h3 id="_2-1-后剪枝-错误降低剪枝" tabindex="-1">2.1 后剪枝：错误降低剪枝 <a class="header-anchor" href="#_2-1-后剪枝-错误降低剪枝" aria-label="Permalink to &quot;2.1 后剪枝：错误降低剪枝&quot;">​</a></h3><p><strong>步骤</strong>：</p><ol><li>将数据集分为训练集和验证集</li><li>验证集用途： <ul><li>已知标签</li><li>测试效果</li><li>不做模型更新</li></ul></li><li>剪枝过程： <ul><li>测试剪去每个可能节点(及其子树)的影响</li><li>贪心地去掉能提升验证集准确率的节点</li><li>直到再剪会损害性能时停止</li></ul></li></ol><p><strong>叶节点标签确定</strong>： 剪枝后，新叶节点的标签通常设置为该节点中多数样本的类别。</p><h3 id="_2-2-预剪枝-vs-后剪枝" tabindex="-1">2.2 预剪枝 vs 后剪枝 <a class="header-anchor" href="#_2-2-预剪枝-vs-后剪枝" aria-label="Permalink to &quot;2.2 预剪枝 vs 后剪枝&quot;">​</a></h3><table tabindex="0"><thead><tr><th>比较项</th><th>预剪枝</th><th>后剪枝</th></tr></thead><tbody><tr><td>速度</td><td>更快</td><td>较慢</td></tr><tr><td>准确率</td><td>一般</td><td>更高</td></tr><tr><td>方法</td><td>基于样本数/信息增益阈值</td><td>错误降低剪枝/规则后剪枝</td></tr></tbody></table><h2 id="_3-决策树实际应用扩展" tabindex="-1">3. 决策树实际应用扩展 <a class="header-anchor" href="#_3-决策树实际应用扩展" aria-label="Permalink to &quot;3. 决策树实际应用扩展&quot;">​</a></h2><h3 id="_3-1-连续属性值处理" tabindex="-1">3.1 连续属性值处理 <a class="header-anchor" href="#_3-1-连续属性值处理" aria-label="Permalink to &quot;3.1 连续属性值处理&quot;">​</a></h3><ul><li><strong>离散化</strong>：将连续值划分为多个区间</li><li>常用方法：二分法、等宽分箱、等频分箱</li></ul><h3 id="_3-2-多值属性处理" tabindex="-1">3.2 多值属性处理 <a class="header-anchor" href="#_3-2-多值属性处理" aria-label="Permalink to &quot;3.2 多值属性处理&quot;">​</a></h3><ul><li>具有过多取值的属性可能导致过拟合</li><li>解决方法：信息增益比、限制分支数量</li></ul><h3 id="_3-3-缺失值处理" tabindex="-1">3.3 缺失值处理 <a class="header-anchor" href="#_3-3-缺失值处理" aria-label="Permalink to &quot;3.3 缺失值处理&quot;">​</a></h3><ul><li>忽略含缺失值的样本</li><li>分配最常用值</li><li>分配概率值(按已知值的分布)</li></ul><h3 id="_3-4-有代价的属性" tabindex="-1">3.4 有代价的属性 <a class="header-anchor" href="#_3-4-有代价的属性" aria-label="Permalink to &quot;3.4 有代价的属性&quot;">​</a></h3><ul><li>考虑获取不同属性的代价</li><li>选择性价比高的分割属性</li></ul><h2 id="_4-决策树优势与演进" tabindex="-1">4. 决策树优势与演进 <a class="header-anchor" href="#_4-决策树优势与演进" aria-label="Permalink to &quot;4. 决策树优势与演进&quot;">​</a></h2><h3 id="_4-1-核心优势" tabindex="-1">4.1 核心优势 <a class="header-anchor" href="#_4-1-核心优势" aria-label="Permalink to &quot;4.1 核心优势&quot;">​</a></h3><ul><li><strong>简单易用</strong>：最常用算法之一</li><li><strong>易于理解</strong>：类似人类决策过程(&quot;如果...就...&quot;)</li><li><strong>实现方便</strong>：计算开销小</li><li><strong>鲁棒性强</strong>：对噪声数据有抵抗力</li></ul><h3 id="_4-2-算法演进" tabindex="-1">4.2 算法演进 <a class="header-anchor" href="#_4-2-算法演进" aria-label="Permalink to &quot;4.2 算法演进&quot;">​</a></h3><ul><li><strong>ID3</strong>：基础算法，使用信息增益</li><li><strong>C4.5</strong>：改进版，处理连续值、缺失值</li><li><strong>C5.0</strong>：更高效版本</li><li><strong>决策森林</strong>：由C4.5产生的多棵决策树组合</li></ul><h2 id="_5-决策树学习总结" tabindex="-1">5. 决策树学习总结 <a class="header-anchor" href="#_5-决策树学习总结" aria-label="Permalink to &quot;5. 决策树学习总结&quot;">​</a></h2><h3 id="_5-1-基础部分" tabindex="-1">5.1 基础部分 <a class="header-anchor" href="#_5-1-基础部分" aria-label="Permalink to &quot;5.1 基础部分&quot;">​</a></h3><ul><li>基本概念与ID3算法</li><li>特征选择与终止条件</li><li>归纳偏置</li><li>过拟合问题</li><li>剪枝技术(预剪枝与后剪枝)</li></ul><h3 id="_5-2-扩展部分" tabindex="-1">5.2 扩展部分 <a class="header-anchor" href="#_5-2-扩展部分" aria-label="Permalink to &quot;5.2 扩展部分&quot;">​</a></h3><ul><li>连续属性离散化</li><li>多值属性处理</li><li>缺失值处理</li><li>有代价属性考虑</li></ul><p>决策树因其直观性和有效性，在实际应用中表现优异。理解这些进阶内容有助于在实际项目中更好地应用和调优决策树模型。</p>',71)]))}const u=a(l,[["render",i]]);export{d as __pageData,u as default};
