import{_ as E,C as i,c as A,o as s,j as r,a3 as a,b as d,a as o,w as n,G as e,a4 as g}from"./chunks/framework.CkaDlzKP.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"AI/1.机器学习/03.决策树/单棵树——一个独立的决策树模型.md","filePath":"AI/1.机器学习/03.决策树/单棵树——一个独立的决策树模型.md","lastUpdated":1754900608000}'),h={name:"AI/1.机器学习/03.决策树/单棵树——一个独立的决策树模型.md"};function u(B,t,_,b,C,p){const l=i("Mermaid");return s(),A("div",null,[t[6]||(t[6]=r("p",null,[o("“"),r("strong",null,"单棵树"),o("”（Single Tree）在机器学习中指的就是"),r("strong",null,"一个独立的决策树模型"),o("（Decision Tree），它是构建更复杂模型（如随机森林、GBDT）的"),r("strong",null,"基础单元"),o("。以下是清晰易懂的解释：")],-1)),t[7]||(t[7]=r("hr",null,null,-1)),t[8]||(t[8]=r("h3",{id:"_1-核心定义",tabindex:"-1"},[r("strong",null,"1. 核心定义"),o(),r("a",{class:"header-anchor",href:"#_1-核心定义","aria-label":'Permalink to "**1. 核心定义**"'},"​")],-1)),r("ul",null,[t[4]||(t[4]=r("li",null,[r("strong",null,"单棵树 = 一个决策树模型"),r("br"),o(" 由"),r("strong",null,"根节点、内部节点（分支）、叶子节点"),o("组成的树形结构，像一棵倒挂的树。")],-1)),r("li",null,[t[1]||(t[1]=r("strong",null,"示例",-1)),t[2]||(t[2]=o("： ",-1)),(s(),d(g,null,{default:n(()=>[e(l,{id:"mermaid-17",class:"mermaid",graph:"graph%20TD%0A%20%20A%5B%E6%A0%B9%E8%8A%82%E7%82%B9%EF%BC%9A%E8%A1%80%E9%87%8F%20%3E%2050%25%EF%BC%9F%5D%20%0A%20%20A%20--%3E%7C%E6%98%AF%7C%20B%5B%E5%86%85%E9%83%A8%E8%8A%82%E7%82%B9%EF%BC%9A%E6%AD%A6%E5%99%A8%E7%AD%89%E7%BA%A7%20%3E%203%EF%BC%9F%5D%0A%20%20A%20--%3E%7C%E5%90%A6%7C%20C%5B%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%9A%E8%83%9C%E7%8E%87%2010%25%5D%0A%20%20B%20--%3E%7C%E6%98%AF%7C%20D%5B%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%9A%E8%83%9C%E7%8E%87%2090%25%5D%0A%20%20B%20--%3E%7C%E5%90%A6%7C%20E%5B%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%9A%E8%83%9C%E7%8E%87%2060%25%5D%0A"})]),fallback:n(()=>t[0]||(t[0]=[o(" Loading... ",-1)])),_:1})),t[3]||(t[3]=o("这就是一棵完整的“单棵树”，可直接用于预测。",-1))])]),t[9]||(t[9]=a('<hr><h3 id="_2-单棵树的特点" tabindex="-1"><strong>2. 单棵树的特点</strong> <a class="header-anchor" href="#_2-单棵树的特点" aria-label="Permalink to &quot;**2. 单棵树的特点**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>结构简单</strong></td><td>规则清晰可见（如“血量&gt;50% 且 武器等级&gt;3 → 胜率90%”）</td></tr><tr><td><strong>训练速度快</strong></td><td>相比深度学习模型，单棵树训练仅需秒/毫秒级</td></tr><tr><td><strong>预测成本低</strong></td><td>预测时只需从根节点走到叶子节点（时间复杂度=树深度）</td></tr><tr><td><strong>可解释性极强</strong></td><td>可直接展示决策逻辑（医疗/金融领域常用）</td></tr><tr><td><strong>容易过拟合</strong></td><td>树深度太大时，会死记硬背训练数据中的噪声（需剪枝）</td></tr></tbody></table><hr><h3 id="_3-单棵树-vs-集成方法" tabindex="-1"><strong>3. 单棵树 vs 集成方法</strong> <a class="header-anchor" href="#_3-单棵树-vs-集成方法" aria-label="Permalink to &quot;**3. 单棵树 vs 集成方法**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>对比项</strong></th><th><strong>单棵树</strong></th><th><strong>随机森林（多棵树）</strong></th></tr></thead><tbody><tr><td><strong>模型数量</strong></td><td>1棵树</td><td>成百上千棵树</td></tr><tr><td><strong>预测方式</strong></td><td>直接由叶子节点输出结果</td><td>综合所有树的预测结果（投票或平均）</td></tr><tr><td><strong>随机性</strong></td><td>无随机性（除非用随机参数训练）</td><td>训练时随机抽样本、抽特征</td></tr><tr><td><strong>稳定性</strong></td><td>对数据敏感，波动大</td><td>多棵树抵消噪声，更稳定</td></tr><tr><td><strong>可解释性</strong></td><td>⭐⭐⭐⭐⭐ 完全透明</td><td>⭐☆☆☆☆ 黑盒（无法直观展示千棵树逻辑）</td></tr></tbody></table><hr><h3 id="_4-单棵树如何训练" tabindex="-1"><strong>4. 单棵树如何训练？</strong> <a class="header-anchor" href="#_4-单棵树如何训练" aria-label="Permalink to &quot;**4. 单棵树如何训练？**&quot;">​</a></h3><p>以分类任务为例：</p><ol><li><strong>从根节点开始</strong>：<br> 遍历所有特征，找到最佳分裂点（如“血量&gt;50%”能使数据纯度提升最多）。</li><li><strong>递归分裂</strong>：<br> 对每个子节点重复上述过程，直到满足停止条件（如树深度=5、节点样本数&lt;10）。</li><li><strong>生成叶子节点</strong>：<br> 停止分裂的节点成为叶子节点，记录该节点内样本的类别比例（如90%胜率）。</li></ol><hr><h3 id="_5-单棵树如何预测" tabindex="-1"><strong>5. 单棵树如何预测？</strong> <a class="header-anchor" href="#_5-单棵树如何预测" aria-label="Permalink to &quot;**5. 单棵树如何预测？**&quot;">​</a></h3><ul><li><strong>输入</strong>：一个新样本（如玩家数据：血量=70%，武器等级=2）。</li><li><strong>流程</strong>： <ol><li>从根节点出发，按条件判断走向子节点（血量70%&gt;50% → 是）</li><li>到达内部节点（武器等级2&lt;3 → 否）</li><li>最终落入叶子节点 → 输出 <strong>胜率60%</strong>（确定性结果，无随机性！）</li></ol></li></ul><hr><h3 id="_6-什么场景适合用单棵树" tabindex="-1"><strong>6. 什么场景适合用单棵树？</strong> <a class="header-anchor" href="#_6-什么场景适合用单棵树" aria-label="Permalink to &quot;**6. 什么场景适合用单棵树？**&quot;">​</a></h3><ul><li><strong>需要模型透明解释</strong>：<br> 银行拒绝贷款时需展示具体规则（“收入&lt;3万且负债&gt;50万 → 拒绝”）。</li><li><strong>低算力设备部署</strong>：<br> 物联网设备（树预测仅需if-else判断）。</li><li><strong>快速验证特征有效性</strong>：<br> 观察树分裂时优先选哪些特征，判断特征重要性。</li><li><strong>教育演示</strong>：<br> 入门机器学习的“教科书式模型”。</li></ul><hr><h3 id="举个实际例子" tabindex="-1">举个实际例子 <a class="header-anchor" href="#举个实际例子" aria-label="Permalink to &quot;举个实际例子&quot;">​</a></h3><p><strong>医疗诊断单棵树</strong>：</p>',19)),(s(),d(g,null,{default:n(()=>[e(l,{id:"mermaid-247",class:"mermaid",graph:"graph%20TD%0A%20%20A%5B%E5%8F%91%E7%83%A7%20%3E%2038.5%E2%84%83%EF%BC%9F%5D%20%0A%20%20A%20--%3E%7C%E6%98%AF%7C%20B%5B%E5%92%B3%E5%97%BD%EF%BC%9F%5D%0A%20%20A%20--%3E%7C%E5%90%A6%7C%20C%5B%E8%AF%8A%E6%96%AD%EF%BC%9A%E6%99%AE%E9%80%9A%E6%84%9F%E5%86%92%20%E6%A6%82%E7%8E%8785%25%5D%0A%20%20B%20--%3E%7C%E6%98%AF%7C%20D%5B%E8%AF%8A%E6%96%AD%EF%BC%9A%E8%82%BA%E7%82%8E%20%E6%A6%82%E7%8E%8770%25%5D%0A%20%20B%20--%3E%7C%E5%90%A6%7C%20E%5B%E8%AF%8A%E6%96%AD%EF%BC%9A%E6%B5%81%E6%84%9F%20%E6%A6%82%E7%8E%8790%25%5D%0A"})]),fallback:n(()=>t[5]||(t[5]=[o(" Loading... ",-1)])),_:1})),t[10]||(t[10]=a('<ul><li><strong>医生可理解</strong>：规则符合医学逻辑。</li><li><strong>患者可信任</strong>：知道诊断依据（“我高烧且咳嗽，所以疑似肺炎”）。</li></ul><hr><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><strong>单棵树 = 一个独立工作的决策树模型</strong>：</p><ul><li>✅ <strong>优点</strong>：简单、快速、透明、易部署。</li><li>⚠️ <strong>缺点</strong>：容易过拟合，复杂问题表现不如随机森林/神经网络。</li><li>💡 <strong>关键认知</strong>： <blockquote><p>它输出的概率（如90%胜率）是叶子节点内<strong>训练数据的统计值</strong>，<br><strong>无需随机数</strong>参与预测过程！</p></blockquote></li></ul><p>当你说“用决策树预测”却未指定随机森林时，默认指的就是<strong>单棵树</strong>。它是理解所有树相关模型的地基！</p>',6))])}const D=E(h,[["render",u]]);export{m as __pageData,D as default};
