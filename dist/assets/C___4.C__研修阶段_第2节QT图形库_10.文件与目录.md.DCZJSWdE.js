import{_ as e,c as r,o as a,a3 as i}from"./chunks/framework.CkaDlzKP.js";const g=JSON.parse('{"title":"Qt图形库概述：文件与目录","description":"","frontmatter":{},"headers":[],"relativePath":"C++/4.C++研修阶段/第2节QT图形库/10.文件与目录.md","filePath":"C++/4.C++研修阶段/第2节QT图形库/10.文件与目录.md","lastUpdated":1754900608000}'),o={name:"C++/4.C++研修阶段/第2节QT图形库/10.文件与目录.md"};function l(n,t,s,d,c,h){return a(),r("div",null,t[0]||(t[0]=[i('<h1 id="qt图形库概述-文件与目录" tabindex="-1">Qt图形库概述：文件与目录 <a class="header-anchor" href="#qt图形库概述-文件与目录" aria-label="Permalink to &quot;Qt图形库概述：文件与目录&quot;">​</a></h1><h2 id="qiodevice类" tabindex="-1">QIODevice类 <a class="header-anchor" href="#qiodevice类" aria-label="Permalink to &quot;QIODevice类&quot;">​</a></h2><p>QIODevice作为Qt中所有输入输出（IO）设备类的抽象基类，为各类IO操作提供了基础的功能接口，涵盖了设备的打开、关闭、数据读取和写入等操作。它还定义了一系列的枚举类型（例如OpenMode）以及信号槽机制，用于处理IO操作期间的状态变化和事件通知。</p><p>QIODevice属于抽象类，无法直接进行实例化。其他具体的IO设备类，如QFile、QBuffer等，均继承自QIODevice，以实现各自特定类型的IO操作。</p><h3 id="重要成员函数" tabindex="-1">重要成员函数 <a class="header-anchor" href="#重要成员函数" aria-label="Permalink to &quot;重要成员函数&quot;">​</a></h3><ul><li><strong>open(OpenMode mode)</strong>：此函数用于打开设备，其中OpenMode是一个枚举类型，可指定打开设备的模式，例如只读（ReadOnly）、只写（WriteOnly）、读写（ReadWrite）等。</li><li><strong>read(qint64 maxSize)</strong>：从设备中读取数据，maxSize参数用于指定最多读取的字节数，函数返回读取到的数据，其类型为QByteArray。</li><li><strong>write(const QByteArray&amp; byteArray)</strong>：向设备写入数据，参数byteArray为要写入的数据，函数返回实际写入的字节数。</li><li><strong>close()</strong>：用于关闭已打开的设备，释放相关资源。</li></ul><h3 id="信号与槽机制" tabindex="-1">信号与槽机制 <a class="header-anchor" href="#信号与槽机制" aria-label="Permalink to &quot;信号与槽机制&quot;">​</a></h3><ul><li><strong>aboutToClose()</strong>：当设备即将关闭时，会发射此信号。</li><li><strong>bytesWritten(qint64 bytes)</strong>：在有数据写入设备时发射，参数bytes表示写入的字节数。</li></ul><h3 id="在qt中io操作的处理方式" tabindex="-1">在Qt中IO操作的处理方式 <a class="header-anchor" href="#在qt中io操作的处理方式" aria-label="Permalink to &quot;在Qt中IO操作的处理方式&quot;">​</a></h3><ul><li>统一的接口简化了文件与外部设备的操作方式</li><li>Qt中的文件被看做是一种特殊的外部设备</li><li>Qt中的文件操作与外部设备操作相同</li></ul><h2 id="qt中io设备类型" tabindex="-1">Qt中IO设备类型 <a class="header-anchor" href="#qt中io设备类型" aria-label="Permalink to &quot;Qt中IO设备类型&quot;">​</a></h2><ul><li><strong>顺序存储设备</strong>：只能从头开始顺序读写数据，不能指定数据的读写位置（如串口）</li><li><strong>随机存储设备</strong>：可以定位到任意位置进行数据读写（通过seek function函数）（如文件）</li></ul><h2 id="qt-io操作类型" tabindex="-1">QT IO操作类型 <a class="header-anchor" href="#qt-io操作类型" aria-label="Permalink to &quot;QT IO操作类型&quot;">​</a></h2><table tabindex="0"><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>QFile</td><td>QFile是Qt中用于文件操作的类，直接支持文本文件（可读文本字符）和数据文件（二进制数据）的读写</td></tr><tr><td>QFileInfo</td><td>用于读取文件属性信息</td></tr><tr><td>QTemporaryFile</td><td>安全创建全局唯一的临时文件，用于大数据传递或进程间通信</td></tr><tr><td>QTextStream</td><td>写入的数据全部转化为可读文本</td></tr><tr><td>QDataStream</td><td>写入的数据根据类型转换为二进制</td></tr><tr><td>QBuffer</td><td>缓冲区的本质为一段连续的存储空间，QBuffer是Qt中缓冲区相关的类</td></tr><tr><td>QDir</td><td>是Qt中功能强大的目录操作类</td></tr><tr><td>QFileSystemWatcher</td><td>用于监控文件和目录的状态变化（内容修改、重命名、删除等）</td></tr></tbody></table><h2 id="qfile类" tabindex="-1">QFile类 <a class="header-anchor" href="#qfile类" aria-label="Permalink to &quot;QFile类&quot;">​</a></h2><p>在Qt中，QFile类主要用于对文件进行读写操作。<strong>QFile</strong>直接继承自<strong>QIODevice</strong>，是专门针对文件操作的类，能够支持文本文件和数据文件的读写。</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>能够对文件执行常规的读写操作，例如打开、关闭、读取全部内容（readAll）、按行读取（readLine）、写入数据（write）等。</li><li>提供了获取文件详细信息的功能，例如文件路径（path）、文件名（fileName）、文件后缀（suffix）、文件大小（size）、创建时间（created）、最后修改时间（lastModified）等（需通过<strong>QFileInfo</strong>类获取）。</li></ul><h3 id="常用方法" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><strong>open(打开方式)</strong>：打开文件 <ul><li><code>QIODevice::WriteOnly</code>：以只写方式打开，新内容会覆盖原内容。</li><li><code>QIODevice::ReadWrite</code>：以读写方式打开，打开时指针在文件头部，内容从文件头开始追加。</li><li><code>QIODevice::Append</code>：以追加方式打开，打开时指针在文件尾部，内容从尾部开始追加。</li></ul></li><li><strong>qint64 write(QByteArray)</strong>：向文件中写入内容，返回值为写入的字符串长度。</li><li><strong>QByteArray read(qint64)</strong>：从文件中读取内容，并返回一个QByteArray，参数为需要读取的最大字节数。</li><li><strong>void close()</strong>：关闭文件。</li></ul><h2 id="qbuffer类" tabindex="-1">QBuffer类 <a class="header-anchor" href="#qbuffer类" aria-label="Permalink to &quot;QBuffer类&quot;">​</a></h2><p>QBuffer继承自QIODevice，它为内存缓冲区提供了输入输出操作的功能。</p><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>缓冲区本质上是一段连续的存储空间，QBuffer将其封装为可进行输入输出操作的对象。</li><li>可以像操作文件一样对缓冲区进行打开（open）、写入（write）、读取（read）和关闭（close）操作。通常与QByteArray结合使用，将数据存储在内存中进行临时处理或在不同组件之间传递数据。</li></ul><h3 id="常用方法-1" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法-1" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><strong>atEnd()</strong>：判断是否已到达缓冲区末尾。</li><li><strong>seek(qint64 pos)</strong>：设置读取位置。</li></ul><h2 id="qabstractsocket类" tabindex="-1">QAbstractSocket类 <a class="header-anchor" href="#qabstractsocket类" aria-label="Permalink to &quot;QAbstractSocket类&quot;">​</a></h2><p>QAbstractSocket继承自QIODevice，是Qt中所有套接字类（如QTcpSocket、QUdpSocket）的抽象基类。</p><h3 id="特点-2" tabindex="-1">特点 <a class="header-anchor" href="#特点-2" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>提供了与网络套接字相关的基本功能，例如连接到服务器（connectToHost）、监听端口（listen）、获取套接字状态（state）、获取本地和远程地址（localhost、peerAddress）等。</li><li>实现了异步的网络通信机制，通过信号槽机制（如connected、disconnected、readyRead等信号）处理网络事件，方便开发者进行网络编程。</li></ul><h3 id="常用方法-2" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法-2" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><strong>error()</strong>：获取套接字的错误。</li><li><strong>flush()</strong>：刷新输出缓冲区。</li></ul><h2 id="qprocess类" tabindex="-1">QProcess类 <a class="header-anchor" href="#qprocess类" aria-label="Permalink to &quot;QProcess类&quot;">​</a></h2><p>QProcess继承自QIODevice，用于启动外部程序并与之进行交互（例如获取程序输出、向程序输入数据等）。</p><h3 id="特点-3" tabindex="-1">特点 <a class="header-anchor" href="#特点-3" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>可以启动外部应用程序，并设置程序的启动参数（setArguments）、工作目录（setWorkingDirectory）等。</li><li>通过信号（如started、finished、readyReadStandardOutput等）和函数（如write、readAllStandardOutput等）与外部程序进行通信，获取程序的执行结果或向程序输入数据。</li></ul><h3 id="常用方法-3" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法-3" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><strong>startDetached()</strong>：以分离模式启动进程。</li><li><strong>kill()</strong>：终止进程。</li></ul><h2 id="qdir类" tabindex="-1">QDir类 <a class="header-anchor" href="#qdir类" aria-label="Permalink to &quot;QDir类&quot;">​</a></h2><p>QDir继承自QObject，提供了跨平台的目录操作接口，能够处理不同操作系统的目录结构和文件属性的差异。用于操作文件系统中的目录，包括获取目录信息、创建、删除目录，以及遍历目录中的文件和子目录等。</p><p>QDir用于操作路径名、访问有关路径和文件的信息以及操作底层文件系统。它还可以用于访问Qt的资源系统。QDir可以使用相对路径或绝对路径指向文件：</p><ul><li><strong>绝对路径</strong>：以目录分隔符开头（在Windows下，可以选择以驱动器规格开头）</li><li><strong>相对路径</strong>：以目录名或文件名开头，并指定相对于当前目录的路径</li></ul><h3 id="常用方法-4" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法-4" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><strong>构造函数</strong>：<code>QDir(const QString &amp;path = QString())</code></li><li><strong>判断路径是否存在</strong>：<code>bool exists() const</code></li><li><strong>判断是否是文件</strong>：<code>bool isFile() const</code></li><li><strong>判断是否是文件夹</strong>：<code>bool isDir() const</code></li><li><strong>获取当前路径</strong>：<code>QString absolutePath() const</code></li><li><strong>获取文件名</strong>：<code>QString fileName() const</code></li><li><strong>获取文件目录</strong>：<code>QString dirName() const</code></li><li><strong>获取文件大小</strong>：<code>qint64 size() const</code></li><li><strong>获取文件的创建时间</strong>：<code>QDateTime created() const</code></li><li><strong>获取文件的最后修改时间</strong>：<code>QDateTime lastModified() const</code></li><li><strong>创建新的目录</strong>：<code>mkdir()</code></li><li><strong>删除空目录</strong>：<code>rmdir()</code></li><li><strong>获取目录中的文件和子目录列表</strong>：<code>entryList()</code></li></ul><h2 id="作业" tabindex="-1">作业 <a class="header-anchor" href="#作业" aria-label="Permalink to &quot;作业&quot;">​</a></h2><p>实现一个文本编辑器，需包含以下功能：</p><ol><li><strong>树状列表</strong>：显示工作路径及其子目录与文件结构</li><li><strong>文本编辑区域</strong>：支持多行文本编辑的基础功能</li><li><strong>文件操作选项</strong>： <ul><li>保存文件</li><li>打开单个文件</li><li>打开整个文件夹（在树状列表中显示目录结构）</li></ul></li></ol>',47)]))}const Q=e(o,[["render",l]]);export{g as __pageData,Q as default};
