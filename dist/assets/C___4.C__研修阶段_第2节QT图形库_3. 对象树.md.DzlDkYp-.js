import{_ as i,c as a,o as n,a3 as l}from"./chunks/framework.C3IOjdSt.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"C++/4.C++研修阶段/第2节QT图形库/3. 对象树.md","filePath":"C++/4.C++研修阶段/第2节QT图形库/3. 对象树.md","lastUpdated":1754900608000}'),e={name:"C++/4.C++研修阶段/第2节QT图形库/3. 对象树.md"};function t(h,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h3 id="属性系统" tabindex="-1">属性系统 <a class="header-anchor" href="#属性系统" aria-label="Permalink to &quot;属性系统&quot;">​</a></h3><p>属性系统：基于元对象系统，通过信号槽提供对象间的通信,不依赖于编译器。<br> QObject 的 setProperty 和 property 用于通过属性名称动态设置和获取属性值。其实主要实现 c++ 和 qml 交互。<br> 由于元对象系统的特点，这就保证了 Qt 属性系统是独立于编译器和平台的。不仅如此，我们还可以使用 Q_PROPERTY() 来定义编译器的静态属性。<br> 使用 Q_PROPERTY 宏定义的属性，就是静态属性。后期使用 setProperty() 动态添加的属性，就是动态属性。</p><p><strong>属性操作方式：</strong></p><ul><li>可使用 <code>QObject::property</code> 和 <code>QObject::setProperty</code> 函数进行存取</li><li>若属性有相关联的存取函数，则可使用存取函数进行存取</li><li>属性还可通过元对象系统的 <code>QMetaObject</code> 类进行存取</li></ul><p><strong>Q_PROPERTY 宏：</strong><br><code>Q_PROPERTY()</code> 宏用来定义可通过元对象系统访问的属性，通过它定义的属性，可以在 QML 中访问、修改，也可以在属性变化时发射特定的信号。<br><code>Q_PROPERTY()</code> 宏定义一个返回值类型为 type，名称为 name 的属性，用 READ、WRITE 关键字定义属性的读取、写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是 QVariant 支持的任何类型，也可以用户自定义类型。</p><p><strong>宏参数说明：</strong></p><ul><li><strong>READ</strong>：用于读取属性值，如果未指定成员变量（通过 MEMBER），则需要读取访问器函数。</li><li><strong>WRITE</strong>：写访问器函数是可选的。用于设置属性值。它必须返回 void，并且必须只接受一个参数，要么是属性的类型，要么是指向该类型的指针或引用。</li><li><strong>MEMBER</strong>：如果未指定读取访问器函数，则需要成员变量关联。这使得给定的成员变量可读写，而无需创建读写访问器函数。如果需要控制变量访问，除了成员变量关联（但不是两者）之外，还可以使用读取访问器函数。</li><li><strong>RESET</strong>：复位功能是可选的。它用于将属性设置回其特定于上下文的默认值。</li><li><strong>NOTIFY</strong>：通知信号是可选的。如果已定义，它应该指定该类中的一个现有信号，该信号在属性值更改时发出。成员变量的通知信号必须采用零个或一个参数，这些参数必须与属性的类型相同。参数将采用属性的新值。仅当属性确实发生更改时才应发出 NOTIFY 信号，以避免绑定在 QML 中被不必要地重新计算。</li></ul><p><strong>语法示例：</strong></p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Q_PROPERTY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(属性类型 属性名 READ 读函数名 WRITE 写入函数名 NOTIFY 信号函数)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用 <code>QObject</code> 的 <code>property()</code> 方法访问属性，如果该属性定义了 WRITE 方法，还可以使用 <code>setProperty()</code> 修改属性。<br><code>Q_PROPERTY</code> 用于 c++ 类注册到 qml 交互上。在 c++ 的变化发送信号，而在 qml 上接收信号，实现处理槽函数。</p><hr><h3 id="对象树" tabindex="-1">对象树 <a class="header-anchor" href="#对象树" aria-label="Permalink to &quot;对象树&quot;">​</a></h3><h4 id="对象树和父子关系" tabindex="-1">对象树和父子关系 <a class="header-anchor" href="#对象树和父子关系" aria-label="Permalink to &quot;对象树和父子关系&quot;">​</a></h4><p>在 Qt 中，对象树和父子关系是内存管理和对象组织的基础机制。</p><h4 id="对象树-1" tabindex="-1">对象树 <a class="header-anchor" href="#对象树-1" aria-label="Permalink to &quot;对象树&quot;">​</a></h4><p>对象树（Object Tree）是 Qt 中用于管理 Qobject 及其子类实例的一种层次结构。</p><h5 id="对象树的组成" tabindex="-1">对象树的组成 <a class="header-anchor" href="#对象树的组成" aria-label="Permalink to &quot;对象树的组成&quot;">​</a></h5><ul><li><strong>QObject</strong>：对象树中的节点，可以是任何继承自 QObject 的类，如 QWidget、QThread、QTimer 等。</li><li><strong>父子关系</strong>：对象树中的节点通过父子关系连接。每个 QObject 可以有多个子 QObject，但每个子 QObject 只能有一个父 QObject。</li></ul><h5 id="对象树的特点" tabindex="-1">对象树的特点 <a class="header-anchor" href="#对象树的特点" aria-label="Permalink to &quot;对象树的特点&quot;">​</a></h5><ul><li><strong>自动管理</strong>：对象树中的子对象会随着其父对象的销毁而自动销毁，这有助于防止内存泄漏。当父对象被删除时，它会遍历其所有子对象，并依次删除它们。这种自动管理机制大大简化了内存管理的复杂性，开发者无需手动跟踪和释放每个子对象的内存。</li><li><strong>层次结构</strong>：对象树反映了对象之间的层次关系，这对于图形用户界面（GUI）应用程序尤其重要，其中窗口和控件通常以层次结构组织。例如，一个主窗口可能包含多个子窗口或控件，这些子窗口和控件又可能包含自己的子控件，形成一个清晰的层次结构。</li><li><strong>生命周期管理</strong>：对象树简化了对象生命周期的管理，因为子对象的生命周期与其父对象紧密相关。这意味着只要父对象存在，子对象就会存在；当父对象被销毁时，子对象也会被自动销毁。</li></ul><hr><h4 id="对象树的操作" tabindex="-1">对象树的操作 <a class="header-anchor" href="#对象树的操作" aria-label="Permalink to &quot;对象树的操作&quot;">​</a></h4><h5 id="添加父对象" tabindex="-1">添加父对象 <a class="header-anchor" href="#添加父对象" aria-label="Permalink to &quot;添加父对象&quot;">​</a></h5><p>创建一个 QObject 时，可以将其作为另一个 QObject 的子对象，通过在构造函数中传递父对象的指针来实现。</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;QObject&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Father</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_OBJECT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Father</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent) {}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~Father</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;父类被析构了&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Son</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_OBJECT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Son</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent) {}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过构造函数增加父对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~Son</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;子类被析构了&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Father;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Son </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Son;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过 setParent 增加父对象</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h5 id="移除父对象" tabindex="-1">移除父对象 <a class="header-anchor" href="#移除父对象" aria-label="Permalink to &quot;移除父对象&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Father;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Son </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Son;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过 setParent 增加父对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过 setParent 设置父对象为nullptr 来移除父对象</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="查询子对象" tabindex="-1">查询子对象 <a class="header-anchor" href="#查询子对象" aria-label="Permalink to &quot;查询子对象&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Father;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Son </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Son;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过 setParent 增加父对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 获取所有的子对象</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="获取父对象" tabindex="-1">获取父对象 <a class="header-anchor" href="#获取父对象" aria-label="Permalink to &quot;获取父对象&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Father;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Son </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Son;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 通过 setParent 增加父对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取父对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">qobject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li>当一个 QObject 被删除时，它会发出 <code>destroyed()</code> 信号，但不会在析构函数中发出，因为那时对象已经不存在了。</li><li>在某些情况下，可能需要手动管理 Qobject 的生命周期，这时可以通过调用 <code>setParent(nullptr)</code> 来移除对象的父子关系。</li><li>对象树不适用于非 Qobject 类型的对象，这些对象需要手动管理内存。</li></ul><h4 id="父子类关系" tabindex="-1">父子类关系 <a class="header-anchor" href="#父子类关系" aria-label="Permalink to &quot;父子类关系&quot;">​</a></h4><p>在 Qt 中，对象之间的父子关系是非常重要的概念，它对于对象的内存管理和事件传递有着重要的影响。</p><h5 id="父子关系的影响" tabindex="-1">父子关系的影响： <a class="header-anchor" href="#父子关系的影响" aria-label="Permalink to &quot;父子关系的影响：&quot;">​</a></h5><ul><li>当父对象被销毁时，它的所有子对象也会被自动销毁。这是 Qt 中自动内存管理的一个重要特性，大大减少了内存泄漏的风险。</li><li>父对象的位置和大小变化也会影响到子对象。例如，如果父窗口的大小发生变化，其子窗口和控件的位置和大小可能会根据布局策略进行相应的调整。</li></ul><h5 id="父子关系的适用范围" tabindex="-1">父子关系的适用范围： <a class="header-anchor" href="#父子关系的适用范围" aria-label="Permalink to &quot;父子关系的适用范围：&quot;">​</a></h5><ul><li>父子关系通常在 GUI 编程中用得比较多，例如窗口和窗口上的控件之间建立父子关系。这样可以方便地管理控件的显示和隐藏，以及在窗口大小变化时进行自动布局调整。</li><li>父子关系对对象的内存管理方面非常有用，能够简化内存释放的过程。特别是在复杂的 GUI 应用中，有大量的控件和对象需要管理，父子关系可以有效地避免内存泄漏。</li></ul><h5 id="注意事项-1" tabindex="-1">注意事项： <a class="header-anchor" href="#注意事项-1" aria-label="Permalink to &quot;注意事项：&quot;">​</a></h5><ul><li><strong>每个 Qobject 只能有一个父对象</strong>：一个 Qobject 不能同时是多个 Qobject 的子对象。如果尝试为一个 Qobject 设置多个父对象，将会导致运行时错误。</li><li><strong>根对象</strong>：对象树中的根对象没有父对象。通常，应用程序的主窗口或主要的控制对象可以作为根对象。</li><li><strong>删除顺序</strong>：当删除一个 <code>qobject</code> 时，它的所有子对象将按照它们被创建的相反顺序被删除。这确保了在删除过程中，子对象的析构函数能够正确处理与父对象相关的资源和状态。</li></ul>`,42)]))}const g=i(e,[["render",t]]);export{c as __pageData,g as default};
