æˆ‘æ²¡æ‰¾åˆ°ç›¸å…³å¤´æ–‡ä»¶çš„è®²è§£ï¼Œä½†æ˜¯æˆ‘æƒ³åˆ°äº†æˆ‘çš„è€å¸ˆå‘Šè¯‰æˆ‘çš„ä¸€å¥è¯ï¼š**ä½ è¦å­¦ä¹ å»çœ‹å¤´æ–‡ä»¶ï¼Œå°†æ¥ä½ è¦åšä¸åŒçš„å·¥ä½œï¼Œéœ€è¦ç”¨åˆ°å„ç§å¤´æ–‡ä»¶ï¼Œä¸å¯èƒ½ä¸€æ­¥ä¸€æ­¥çš„æ•™**ã€‚ğŸ˜­

## å¤´æ–‡ä»¶å
#### **`onnxruntime_cxx_api.h`**
- è¿™æ˜¯**æœ€ä¸»è¦çš„å¤´æ–‡ä»¶**ï¼ŒåŒ…å«æ‰€æœ‰æ ¸å¿ƒç±»å’Œå‡½æ•°
- ç›¸å½“äºONNX Runtimeçš„"æ€»æ§åˆ¶ä¸­å¿ƒ"
- æˆ‘ä»¬ä¹‹å‰çš„æ‰€æœ‰ä»£ç éƒ½åŸºäºè¿™ä¸ªå¤´æ–‡ä»¶
#### **`onnxruntime_cxx_inline.h`**
- åŒ…å«ä¸€äº›å†…è”å‡½æ•°çš„å®ç°
- é€šå¸¸ç”±ä¸»å¤´æ–‡ä»¶è‡ªåŠ¨åŒ…å«ï¼Œä¸éœ€è¦ç›´æ¥åŒ…å«
## æ·±å…¥ç†è§£Â `onnxruntime_cxx_api.h`
- å…ˆæŒæ¡æ ¸å¿ƒç±»ï¼ˆEnv, Session, Valueï¼‰
- å†å­¦ä¹ è¾…åŠ©ç±»ï¼ˆMemoryInfo, Allocatorï¼‰
- æœ€åäº†è§£é«˜çº§åŠŸèƒ½ï¼ˆè‡ªå®šä¹‰æ“ä½œç¬¦ç­‰ï¼‰
### 1. ç¯å¢ƒç®¡ç†ç±» (`Ort::Env`)

**ä½œç”¨**ï¼šç®¡ç†ONNX Runtimeçš„å…¨å±€çŠ¶æ€

```cpp
// åœ¨å¤´æ–‡ä»¶ä¸­çš„å®šä¹‰ï¼ˆç®€åŒ–ç†è§£ï¼‰
class Env {
public:
    // æ„é€ å‡½æ•°
    Env(OrtLoggingLevel logging_level, const char* logid);
    
    // æ—¥å¿—çº§åˆ«æšä¸¾
    enum LoggingLevel {
        ORT_LOGGING_LEVEL_VERBOSE,
        ORT_LOGGING_LEVEL_INFO,
        ORT_LOGGING_LEVEL_WARNING,
        ORT_LOGGING_LEVEL_ERROR,
        ORT_LOGGING_LEVEL_FATAL
    };
};
```

**å®é™…ä½¿ç”¨**ï¼š
```cpp
// åˆ›å»ºç¯å¢ƒå®ä¾‹
Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "MyApp");
```

### 2. ä¼šè¯é€‰é¡¹ç±» (`Ort::SessionOptions`)

**ä½œç”¨**ï¼šé…ç½®æ¨¡å‹æ¨ç†çš„è¡Œä¸º

```cpp
class SessionOptions {
public:
    SessionOptions();
    
    // è®¾ç½®çº¿ç¨‹æ•°
    void SetIntraOpNumThreads(int num_threads);
    void SetInterOpNumThreads(int num_threads);
    
    // è®¾ç½®æ‰§è¡Œæä¾›å™¨ï¼ˆCPU/GPUï¼‰
    void AppendExecutionProvider_CUDA(const OrtCUDAProviderOptions& options);
    
    // å›¾ä¼˜åŒ–è®¾ç½®
    void SetGraphOptimizationLevel(GraphOptimizationLevel level);
};
```

**å®é™…ä½¿ç”¨**ï¼š
```cpp
Ort::SessionOptions session_options;
session_options.SetIntraOpNumThreads(1);
```

### 3. ä¼šè¯ç±» (`Ort::Session`)

**ä½œç”¨**ï¼šåŠ è½½å’Œæ‰§è¡ŒONNXæ¨¡å‹ï¼Œæ˜¯ONNX Runtimeçš„æ ¸å¿ƒç±»

```C++
class Session {
public:
    // æ„é€ å‡½æ•° - ä»æ–‡ä»¶åŠ è½½æ¨¡å‹
    Session(const Env& env, const char* model_path, const SessionOptions& options);
    
    // æ„é€ å‡½æ•° - ä»å†…å­˜ç¼“å†²åŒºåŠ è½½æ¨¡å‹
    Session(const Env& env, const void* model_data, size_t model_data_length, 
            const SessionOptions& options);
    
    // ç§»åŠ¨æ„é€ å‡½æ•°å’Œèµ‹å€¼ï¼ˆé‡è¦ï¼šSessionä¸å¯æ‹·è´ï¼‰
    Session(Session&& other) noexcept;
    Session& operator=(Session&& other) noexcept;
    
    // è·å–æ¨¡å‹è¾“å…¥ä¿¡æ¯
    size_t GetInputCount() const;
    const char* GetInputName(size_t index, Allocator& allocator) const;
    TypeInfo GetInputTypeInfo(size_t index) const;
    
    // è·å–æ¨¡å‹è¾“å‡ºä¿¡æ¯
    size_t GetOutputCount() const;
    const char* GetOutputName(size_t index, Allocator& allocator) const;
    TypeInfo GetOutputTypeInfo(size_t index) const;
    
    // è¿è¡Œæ¨ç† - ä¸»è¦æ–¹æ³•
    std::vector<Value> Run(const RunOptions& run_options,
                          const char* const* input_names,
                          const Value* input_values, size_t input_count,
                          const char* const* output_names, size_t output_count);
    
    // è¿è¡Œæ¨ç† - ç®€åŒ–ç‰ˆæœ¬
    std::vector<Value> Run(const std::vector<std::string>& input_names,
                          const std::vector<Value>& input_values,
                          const std::vector<std::string>& output_names);
    
    // è·å–æ¨¡å‹å…ƒæ•°æ®
    const ModelMetadata& GetModelMetadata() const;
    
    // è·å–ä¼šè¯é…ç½®
    const SessionOptions& GetSessionOptions() const;
    
    // ç»“æŸ profilingï¼ˆå¦‚æœå¯ç”¨ï¼‰
    void EndProfiling();
};
```

### åŸºæœ¬ç”¨æ³•ï¼š

```C++
// åˆ›å»ºä¼šè¯
Ort::Session session(env, "model.onnx", session_options);

// è·å–è¾“å…¥è¾“å‡ºä¿¡æ¯
Ort::AllocatorWithDefaultOptions allocator;
size_t num_inputs = session.GetInputCount();
size_t num_outputs = session.GetOutputCount();

// è¿è¡Œæ¨ç†
std::vector<const char*> input_names = {"input"};
std::vector<const char*> output_names = {"output"};
std::vector<Ort::Value> outputs = session.Run(
    nullptr,  // run_options
    input_names.data(), 
    input_values.data(), 
    input_values.size(),
    output_names.data(), 
    output_names.size()
);
```

### 4. å¼ é‡å€¼ç±» (`Ort::Value`)

**ä½œç”¨**ï¼šè¡¨ç¤ºè¾“å…¥å’Œè¾“å‡ºçš„å¼ é‡æ•°æ®ï¼Œç®¡ç†å¼ é‡çš„å†…å­˜å’Œå…ƒæ•°æ®

```cpp
class Value {
public:
    // æ„é€ å‡½æ•°å’Œææ„å‡½æ•°
    Value();
    Value(const Value& other);
    Value(Value&& other) noexcept;
    ~Value();
    
    // èµ‹å€¼è¿ç®—ç¬¦
    Value& operator=(const Value& other);
    Value& operator=(Value&& other) noexcept;
    
    // åˆ›å»ºå¼ é‡çš„é™æ€å·¥å‚æ–¹æ³•
    static Value CreateTensor(const OrtMemoryInfo* info, void* p_data, 
                             size_t p_data_byte_count, const int64_t* shape, 
                             size_t shape_count, ONNXTensorElementDataType type);
    
    static Value CreateTensor(const Ort::MemoryInfo& info, void* p_data, 
                             size_t p_data_byte_count, const int64_t* shape, 
                             size_t shape_count, ONNXTensorElementDataType type);
    
    static Value CreateTensorAsOrtValue(OrtAllocator* allocator, const int64_t* shape, 
                                       size_t shape_count, ONNXTensorElementDataType type);
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºå¼ é‡
    bool IsTensor() const;
    
    // è·å–å¼ é‡ç±»å‹å’Œå½¢çŠ¶ä¿¡æ¯
    Ort::TensorTypeAndShapeInfo GetTensorTypeAndShapeInfo() const;
    
    // è·å–å¼ é‡æ•°æ®ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰
    template<typename T> 
    T* GetTensorMutableData();
    
    template<typename T> 
    const T* GetTensorData() const;
    
    // è·å–åŸå§‹æ•°æ®æŒ‡é’ˆ
    void* GetTensorMutableRawData();
    const void* GetTensorRawData() const;
    
    // è·å–å¼ é‡å…ƒç´ ç±»å‹
    ONNXTensorElementDataType GetTensorElementType() const;
    
    // è·å–å¼ é‡å½¢çŠ¶
    std::vector<int64_t> GetTensorShape() const;
    size_t GetTensorShapeElementCount() const;
    
    // è·å–å¼ é‡å­—èŠ‚å¤§å°
    size_t GetTensorTypeAndShapeDataByteCount() const;
    
    // è·å–å†…éƒ¨OrtValueæŒ‡é’ˆï¼ˆç”¨äºC APIäº¤äº’ï¼‰
    OrtValue* release();
    OrtValue* get() const;
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool operator!() const;
    explicit operator bool() const;
};
```

###  å¼ é‡ç±»å‹å’Œå½¢çŠ¶ä¿¡æ¯ç±» (`Ort::TensorTypeAndShapeInfo`)

**ä½œç”¨**ï¼šæä¾›å¼ é‡çš„ç±»å‹å’Œå½¢çŠ¶ä¿¡æ¯

```cpp
class TensorTypeAndShapeInfo {
public:
    // è·å–å…ƒç´ ç±»å‹
    ONNXTensorElementDataType GetElementType() const;
    
    // è·å–å½¢çŠ¶ä¿¡æ¯
    size_t GetDimensionsCount() const;
    void GetDimensions(int64_t* dim_values, size_t dim_values_length) const;
    std::vector<int64_t> GetShape() const;
    
    // è·å–å…ƒç´ æ€»æ•°
    size_t GetElementCount() const;
};
```

### å®é™…ä½¿ç”¨ç¤ºä¾‹

```cpp
// åˆ›å»ºè¾“å…¥å¼ é‡
Ort::Value CreateInputTensor(const std::vector<float>& input_data, 
                            const std::vector<int64_t>& input_shape) {
    // è·å–å†…å­˜ä¿¡æ¯
    auto memory_info = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    
    // åˆ›å»ºå¼ é‡
    auto input_tensor = Ort::Value::CreateTensor<float>(
        memory_info, 
        const_cast<float*>(input_data.data()), 
        input_data.size() * sizeof(float),
        input_shape.data(), 
        input_shape.size()
    );
    
    return input_tensor;
}

// ä½¿ç”¨å¼ é‡
void ProcessTensor(const Ort::Value& tensor) {
    if (tensor.IsTensor()) {
        auto type_shape = tensor.GetTensorTypeAndShapeInfo();
        auto shape = type_shape.GetShape();
        auto element_type = type_shape.GetElementType();
        auto element_count = type_shape.GetElementCount();
        
        if (element_type == ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT) {
            float* data = tensor.GetTensorMutableData<float>();
            // å¤„ç†æ•°æ®...
        }
    }
}

// æ‰¹é‡å¤„ç†ç¤ºä¾‹
std::vector<Ort::Value> CreateInputTensors(
    const std::vector<std::vector<float>>& inputs,
    const std::vector<int64_t>& shape) {
    
    std::vector<Ort::Value> input_tensors;
    auto memory_info = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    
    for (const auto& input_data : inputs) {
        input_tensors.push_back(Ort::Value::CreateTensor<float>(
            memory_info,
            const_cast<float*>(input_data.data()),
            input_data.size() * sizeof(float),
            shape.data(),
            shape.size()
        ));
    }
    
    return input_tensors;
}
```


å¥½çš„ï¼Œæˆ‘æ¥ä¸ºä½ æä¾›æ›´å…¨é¢çš„ `Ort::MemoryInfo` ç±»å’Œç›¸å…³å†…å­˜ç®¡ç†åŠŸèƒ½çš„è¯¦ç»†è¯´æ˜ï¼š

### 5. å†…å­˜ä¿¡æ¯ç±» (`Ort::MemoryInfo`)

**ä½œç”¨**ï¼šæè¿°å†…å­˜çš„åˆ†é…ä½ç½®ã€ç±»å‹å’Œåˆ†é…å™¨ä¿¡æ¯

```cpp
class MemoryInfo {
public:
    // æ„é€ å‡½æ•°å’Œææ„å‡½æ•°
    MemoryInfo();
    explicit MemoryInfo(const OrtMemoryInfo* info);
    MemoryInfo(const MemoryInfo& other);
    MemoryInfo(MemoryInfo&& other) noexcept;
    ~MemoryInfo();
    
    // èµ‹å€¼è¿ç®—ç¬¦
    MemoryInfo& operator=(const MemoryInfo& other);
    MemoryInfo& operator=(MemoryInfo&& other) noexcept;
    
    // é™æ€å·¥å‚æ–¹æ³•ï¼šåˆ›å»ºCPUå†…å­˜ä¿¡æ¯
    static MemoryInfo CreateCpu(OrtAllocatorType alloc_type, OrtMemType mem_type);
    
    // è·å–å†…å­˜ä¿¡æ¯å±æ€§
    const char* GetName() const;                    // è·å–è®¾å¤‡åç§°ï¼ˆå¦‚"Cpu", "Cuda"ï¼‰
    OrtAllocatorType GetAllocatorType() const;      // è·å–åˆ†é…å™¨ç±»å‹
    OrtMemType GetMemoryType() const;               // è·å–å†…å­˜ç±»å‹
    int GetDeviceId() const;                        // è·å–è®¾å¤‡ID
    OrtMemoryInfoDeviceType GetDeviceType() const;  // è·å–è®¾å¤‡ç±»å‹
    
    // æ¯”è¾ƒæ“ä½œ
    bool operator==(const MemoryInfo& other) const;
    bool operator!=(const MemoryInfo& other) const;
    
    // è·å–å†…éƒ¨æŒ‡é’ˆï¼ˆç”¨äºC APIäº¤äº’ï¼‰
    const OrtMemoryInfo* Get() const;
    OrtMemoryInfo* release();
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool IsNotNull() const;
};
```

#### åˆ†é…å™¨ç±» (`Ort::Allocator`)

**ä½œç”¨**ï¼šç®¡ç†å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾

```cpp
class Allocator {
public:
    // æ„é€ å‡½æ•°
    Allocator(const Session& session, const MemoryInfo& memory_info);
    
    // å†…å­˜åˆ†é…æ–¹æ³•
    void* Alloc(size_t size);
    void* Alloc(size_t size, size_t alignment);
    
    // å†…å­˜é‡Šæ”¾æ–¹æ³•
    void Free(void* p);
    
    // è·å–å†…å­˜ä¿¡æ¯
    MemoryInfo GetMemoryInfo() const;
    
    // è·å–åˆ†é…ç»Ÿè®¡ä¿¡æ¯
    OrtAllocatorStats GetStats() const;
    
    // è·å–å†…éƒ¨æŒ‡é’ˆ
    OrtAllocator* Get() const;
};
```

#### ç›¸å…³æšä¸¾å’Œç±»å‹å®šä¹‰

```cpp
// åˆ†é…å™¨ç±»å‹
enum OrtAllocatorType {
    OrtInvalidAllocator = -1,
    OrtDeviceAllocator = 0,    // è®¾å¤‡åˆ†é…å™¨
    OrtArenaAllocator = 1,     // å†…å­˜æ± åˆ†é…å™¨
    OrtArenaAllocatorV2 = 2    // æ”¹è¿›çš„å†…å­˜æ± åˆ†é…å™¨
};

// å†…å­˜ç±»å‹
enum OrtMemType {
    OrtMemTypeDefault = 0,     // é»˜è®¤å†…å­˜
    OrtMemTypeCPU = 1,         // CPUå†…å­˜
    OrtMemTypeCPUOutput = 2,   // CPUè¾“å‡ºå†…å­˜
    OrtMemTypeCPUInput = 3,    // CPUè¾“å…¥å†…å­˜
    OrtMemTypeCUDA = 4,        // CUDAå†…å­˜
    OrtMemTypeCUDAOutput = 5,  // CUDAè¾“å‡ºå†…å­˜
    OrtMemTypeCUDAInput = 6    // CUDAè¾“å…¥å†…å­˜
};

// è®¾å¤‡ç±»å‹
enum OrtMemoryInfoDeviceType {
    OrtMemoryInfoDeviceType_CPU = 0,
    OrtMemoryInfoDeviceType_CUDA = 1,
    OrtMemoryInfoDeviceType_DML = 2,
    OrtMemoryInfoDeviceType_OpenVINO = 3,
    OrtMemoryInfoDeviceType_CoreML = 4
};
```

####  å®é™…ä½¿ç”¨ç¤ºä¾‹

```cpp
// åˆ›å»ºä¸åŒç±»å‹çš„å†…å­˜ä¿¡æ¯
void CreateMemoryInfos() {
    // CPUé»˜è®¤å†…å­˜
    auto cpu_default = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    
    // CPUè¾“å…¥å†…å­˜
    auto cpu_input = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPUInput);
    
    // CPUè¾“å‡ºå†…å­˜
    auto cpu_output = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPUOutput);
    
    std::cout << "CPU Default: " << cpu_default.GetName() << std::endl;
    std::cout << "CPU Input: " << cpu_input.GetName() << std::endl;
    std::cout << "CPU Output: " << cpu_output.GetName() << std::endl;
}

// åˆ›å»ºå¼ é‡æ—¶ä½¿ç”¨å†…å­˜ä¿¡æ¯
Ort::Value CreateTensorWithMemoryInfo() {
    std::vector<float> data = {1.0f, 2.0f, 3.0f, 4.0f};
    std::vector<int64_t> shape = {2, 2};
    
    // åˆ›å»ºCPUå†…å­˜ä¿¡æ¯
    auto memory_info = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    
    // åˆ›å»ºå¼ é‡
    return Ort::Value::CreateTensor<float>(
        memory_info,
        data.data(),
        data.size() * sizeof(float),
        shape.data(),
        shape.size(),
        ONNXTensorElementDataType::ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT
    );
}

// æ¯”è¾ƒå†…å­˜ä¿¡æ¯
bool IsCpuMemory(const Ort::MemoryInfo& memory_info) {
    auto cpu_memory = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    return memory_info == cpu_memory;
}

// ä½¿ç”¨åˆ†é…å™¨
void UseAllocator(Ort::Session& session) {
    // åˆ›å»ºCPUåˆ†é…å™¨
    auto memory_info = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeDefault);
    Ort::Allocator allocator(session, memory_info);
    
    // åˆ†é…å†…å­˜
    void* buffer = allocator.Alloc(1024); // åˆ†é…1KBå†…å­˜
    
    // ä½¿ç”¨å†…å­˜...
    
    // é‡Šæ”¾å†…å­˜
    allocator.Free(buffer);
}
```

#### å†…å­˜ä¿¡æ¯çš„é«˜çº§ç”¨æ³•

```cpp
// æ£€æŸ¥å†…å­˜å…¼å®¹æ€§
bool IsMemoryCompatible(const Ort::MemoryInfo& required, const Ort::MemoryInfo& available) {
    return required.GetDeviceType() == available.GetDeviceType() &&
           required.GetDeviceId() == available.GetDeviceId();
}

// è·å–è®¾å¤‡ç‰¹å®šçš„å†…å­˜ä¿¡æ¯
void PrintMemoryInfoDetails(const Ort::MemoryInfo& memory_info) {
    std::cout << "Device Name: " << memory_info.GetName() << std::endl;
    std::cout << "Device Type: " << memory_info.GetDeviceType() << std::endl;
    std::cout << "Device ID: " << memory_info.GetDeviceId() << std::endl;
    std::cout << "Allocator Type: " << memory_info.GetAllocatorType() << std::endl;
    std::cout << "Memory Type: " << memory_info.GetMemoryType() << std::endl;
}

// åˆ›å»ºç‰¹å®šè®¾å¤‡çš„å†…å­˜ä¿¡æ¯ï¼ˆéœ€è¦æ‰©å±•APIï¼‰
Ort::MemoryInfo CreateCudaMemoryInfo(int device_id = 0) {
    // æ³¨æ„ï¼šè¿™é€šå¸¸éœ€è¦é€šè¿‡C APIæˆ–ç‰¹å®šæä¾›å™¨APIå®ç°
    OrtMemoryInfo* cuda_memory_info;
    Ort::ThrowOnError(Ort::GetApi().CreateMemoryInfo(
        "Cuda", OrtMemoryInfoDeviceType::OrtMemoryInfoDeviceType_CUDA, 
        device_id, OrtMemType::OrtMemTypeDefault, &cuda_memory_info));
    
    return Ort::MemoryInfo(cuda_memory_info);
}
```

è¿™æ ·çš„å†…å­˜ä¿¡æ¯ç±»è®¾è®¡ç¡®ä¿äº†ONNX Runtimeèƒ½å¤Ÿæ­£ç¡®å¤„ç†ä¸åŒè®¾å¤‡ä¸Šçš„å†…å­˜åˆ†é…å’Œæ•°æ®ä¼ è¾“ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤šè®¾å¤‡ï¼ˆCPUã€GPUç­‰ï¼‰ç¯å¢ƒä¸­éå¸¸é‡è¦ã€‚
### 6.åˆ†é…å™¨ç±» (`Ort::AllocatorWithDefaultOptions`)

**ä½œç”¨**ï¼šæä¾›é»˜è®¤çš„å†…å­˜åˆ†é…ç­–ç•¥ï¼Œç”¨äºè·å–æ¨¡å‹è¾“å…¥è¾“å‡ºåç§°ç­‰å­—ç¬¦ä¸²ä¿¡æ¯

```c++
class AllocatorWithDefaultOptions {
public:
    AllocatorWithDefaultOptions();
    
    // åˆ†é…å†…å­˜
    void* Alloc(size_t size);
    
    // é‡Šæ”¾å†…å­˜
    void Free(void* p);
    
    // è·å–åˆ†é…å™¨ä¿¡æ¯
    const OrtMemoryInfo& GetInfo() const;
};
```

## å®é™…ä½¿ç”¨ï¼š

```c++
// è·å–æ¨¡å‹è¾“å…¥è¾“å‡ºåç§°çš„å…¸å‹ç”¨æ³•
void initializeModelInfo(Ort::Session& session) {
    Ort::AllocatorWithDefaultOptions allocator;
    
    // è·å–è¾“å…¥èŠ‚ç‚¹ä¿¡æ¯
    size_t num_input_nodes = session.GetInputCount();
    for (size_t i = 0; i < num_input_nodes; i++) {
        // ä½¿ç”¨åˆ†é…å™¨è·å–è¾“å…¥åç§°
        char* input_name = session.GetInputName(i, allocator);
        std::cout << "Input " << i << ": " << input_name << std::endl;
        
        // éœ€è¦æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ï¼ˆé‡è¦ï¼ï¼‰
        allocator.Free(input_name);
    }
    
    // è·å–è¾“å‡ºèŠ‚ç‚¹ä¿¡æ¯
    size_t num_output_nodes = session.GetOutputCount();
    for (size_t i = 0; i < num_output_nodes; i++) {
        // ä½¿ç”¨åˆ†é…å™¨è·å–è¾“å‡ºåç§°
        char* output_name = session.GetOutputName(i, allocator);
        std::cout << "Output " << i << ": " << output_name << std::endl;
        
        // éœ€è¦æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ï¼ˆé‡è¦ï¼ï¼‰
        allocator.Free(output_name);
    }
}
```


## 7. é”™è¯¯æ£€æŸ¥ç±» (`Ort::ThrowOnError`)

**ä½œç”¨**ï¼šåŒ…è£…ONNX Runtime APIè°ƒç”¨ï¼Œåœ¨å‘ç”Ÿé”™è¯¯æ—¶è‡ªåŠ¨æŠ›å‡ºå¼‚å¸¸

```cpp
class ThrowOnError {
public:
    // ä¸»è¦æ„é€ å‡½æ•°ï¼Œæ¥å—OrtStatusæŒ‡é’ˆ
    explicit ThrowOnError(OrtStatus* status);
    
    // å¤åˆ¶æ„é€ å‡½æ•°ï¼ˆé€šå¸¸è¢«åˆ é™¤ï¼‰
    ThrowOnError(const ThrowOnError&) = delete;
    
    // ç§»åŠ¨æ„é€ å‡½æ•°
    ThrowOnError(ThrowOnError&&) = delete;
    
    // èµ‹å€¼è¿ç®—ç¬¦ï¼ˆé€šå¸¸è¢«åˆ é™¤ï¼‰
    ThrowOnError& operator=(const ThrowOnError&) = delete;
    
    // ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦
    ThrowOnError& operator=(ThrowOnError&&) = delete;
    
    // ææ„å‡½æ•°ï¼ˆå¤„ç†çŠ¶æ€é‡Šæ”¾ï¼‰
    ~ThrowOnError();
};
```

#### **å®é™…ä½¿ç”¨**ï¼š
```cpp
// åŒ…è£…ä»»ä½•è¿”å›OrtStatus*çš„APIè°ƒç”¨
Ort::ThrowOnError(OrtGetApi().CreateEnv(ORT_LOGGING_LEVEL_WARNING, "test", &env));

// æˆ–è€…ä½¿ç”¨C APIç›´æ¥è°ƒç”¨
OrtStatus* status = OrtCreateEnv(ORT_LOGGING_LEVEL_WARNING, "test", &env);
Ort::ThrowOnError(status);  // å¦‚æœstatusä¸ä¸ºnullptrï¼Œä¼šæŠ›å‡ºå¼‚å¸¸
```

**å·¥ä½œæœºåˆ¶**ï¼š
1. æ„é€ å‡½æ•°æ¥æ”¶ `OrtStatus*` æŒ‡é’ˆ
2. å¦‚æœæŒ‡é’ˆä¸ä¸º `nullptr`ï¼Œæå–é”™è¯¯ä¿¡æ¯å¹¶æŠ›å‡º `Ort::Exception`
3. å¦‚æœæŒ‡é’ˆä¸º `nullptr`ï¼ˆè¡¨ç¤ºæˆåŠŸï¼‰ï¼Œä»€ä¹ˆéƒ½ä¸åš
4. ææ„å‡½æ•°ç¡®ä¿ `OrtStatus` èµ„æºè¢«æ­£ç¡®é‡Šæ”¾

**å¼‚å¸¸ç±»å‹**ï¼šæŠ›å‡º `Ort::Exception`ï¼ŒåŒ…å«ï¼š
- é”™è¯¯æ¶ˆæ¯å­—ç¬¦ä¸²
- é”™è¯¯ä»£ç 
- è°ƒç”¨æ ˆä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰

è¿™ç§è®¾è®¡éµå¾ªäº†RAIIåŸåˆ™ï¼Œç¡®ä¿å³ä½¿åœ¨å¼‚å¸¸æƒ…å†µä¸‹èµ„æºä¹Ÿèƒ½è¢«æ­£ç¡®æ¸…ç†ã€‚

## å¤´æ–‡ä»¶ä¸­çš„å…³é”®æšä¸¾å’Œç±»å‹

### æ—¥å¿—çº§åˆ« (`OrtLoggingLevel`)
```cpp
typedef enum OrtLoggingLevel {
  ORT_LOGGING_LEVEL_VERBOSE = 0,   // æœ€è¯¦ç»†
  ORT_LOGGING_LEVEL_INFO = 1,      // ä¸€èˆ¬ä¿¡æ¯
  ORT_LOGGING_LEVEL_WARNING = 2,   // è­¦å‘Šï¼ˆæ¨èï¼‰
  ORT_LOGGING_LEVEL_ERROR = 3,     // é”™è¯¯
  ORT_LOGGING_LEVEL_FATAL = 4      // è‡´å‘½é”™è¯¯
} OrtLoggingLevel;
```

### å›¾ä¼˜åŒ–çº§åˆ« (`GraphOptimizationLevel`)
```cpp
typedef enum GraphOptimizationLevel {
  ORT_DISABLE_ALL = 0,             // ç¦ç”¨æ‰€æœ‰ä¼˜åŒ–
  ORT_ENABLE_BASIC = 1,            // åŸºæœ¬ä¼˜åŒ–
  ORT_ENABLE_EXTENDED = 2,         // æ‰©å±•ä¼˜åŒ–
  ORT_ENABLE_ALL = 99              // æ‰€æœ‰ä¼˜åŒ–
} GraphOptimizationLevel;
```

##  å®é™…ä»£ç ä¸å¤´æ–‡ä»¶çš„å¯¹åº”å…³ç³»

è®©æˆ‘ä»¬çœ‹çœ‹ä¹‹å‰ä»£ç ä¸­æ¯ä¸ªéƒ¨åˆ†å¯¹åº”çš„å¤´æ–‡ä»¶å®šä¹‰ï¼š

### ç¯å¢ƒåˆå§‹åŒ–
```cpp
// æˆ‘ä»¬çš„ä»£ç 
Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "CIFAR10_Classifier");

// å¯¹åº”å¤´æ–‡ä»¶ä¸­çš„æ„é€ å‡½æ•°
// Env(OrtLoggingLevel logging_level, const char* logid);
```

### ä¼šè¯åˆ›å»º
```cpp
// æˆ‘ä»¬çš„ä»£ç 
Ort::Session session(env, "model.onnx", session_options);

// å¯¹åº”å¤´æ–‡ä»¶ä¸­çš„æ„é€ å‡½æ•°
// Session(const Env& env, const char* model_path, const SessionOptions& options);
```

### å¼ é‡åˆ›å»º
```cpp
// æˆ‘ä»¬çš„ä»£ç 
Ort::Value input_tensor = Ort::Value::CreateTensor<float>(...);

// å¯¹åº”å¤´æ–‡ä»¶ä¸­çš„é™æ€æ–¹æ³•
// static Value CreateTensor(...);
```


## CUDAæ‰§è¡Œæä¾›å™¨å‡½æ•°

### CUDAæ‰§è¡Œæä¾›å™¨å‡½æ•°

**ä½œç”¨**ï¼šä¸ºä¼šè¯é€‰é¡¹æ·»åŠ CUDA GPUåŠ é€Ÿæ”¯æŒ

```cpp
// C API å‡½æ•°åŸå‹
ORT_API2_STATUS(OrtSessionOptionsAppendExecutionProvider_CUDA,
                _In_ OrtSessionOptions* options,
                _In_ const OrtCUDAProviderOptions* provider_options);

// C++ API åŒ…è£…å™¨
void Ort::SessionOptions::AppendExecutionProvider_CUDA(
    const OrtCUDAProviderOptions& provider_options);
```

### CUDAæä¾›å™¨é€‰é¡¹ç»“æ„ä½“ (`OrtCUDAProviderOptions`)

**ä½œç”¨**ï¼šé…ç½®CUDAæ‰§è¡Œæä¾›å™¨çš„å‚æ•°

```cpp
struct OrtCUDAProviderOptions {
    int device_id;                          // GPUè®¾å¤‡ID
    int cudnn_conv_algo_search;            // cuDNNå·ç§¯ç®—æ³•æœç´¢æ¨¡å¼
    OrtCudnnConvAlgoSearch algo_search;    // ç®—æ³•æœç´¢æšä¸¾
    size_t gpu_mem_limit;                   // GPUå†…å­˜é™åˆ¶
    OrtArenaExtendStrategy arena_extend_strategy; // å†…å­˜æ‰©å±•ç­–ç•¥
    int do_copy_in_default_stream;         // æ˜¯å¦åœ¨é»˜è®¤æµä¸­å¤åˆ¶
    int has_user_compute_stream;           // æ˜¯å¦ä½¿ç”¨ç”¨æˆ·è®¡ç®—æµ
    void* user_compute_stream;             // ç”¨æˆ·è®¡ç®—æµæŒ‡é’ˆ
};
```

###  å®é™…ä½¿ç”¨ç¤ºä¾‹

```cpp
#include <onnxruntime_cxx_api.h>

void setupCUDASession() {
    // åˆ›å»ºä¼šè¯é€‰é¡¹
    Ort::SessionOptions session_options;
    
    // é…ç½®CUDAæä¾›å™¨é€‰é¡¹
    OrtCUDAProviderOptions cuda_options;
    cuda_options.device_id = 0;                    // ä½¿ç”¨ç¬¬ä¸€ä¸ªGPU
    cuda_options.arena_extend_strategy = 0;         // å†…å­˜æ‰©å±•ç­–ç•¥
    cuda_options.gpu_mem_limit = 2 * 1024 * 1024 * 1024UL; // 2GBå†…å­˜é™åˆ¶
    cuda_options.cudnn_conv_algo_search = OrtCudnnConvAlgoSearchExhaustive;
    cuda_options.do_copy_in_default_stream = 1;
    
    // æ·»åŠ CUDAæ‰§è¡Œæä¾›å™¨
    Ort::ThrowOnError(OrtSessionOptionsAppendExecutionProvider_CUDA(
        session_options, 
        &cuda_options
    ));
    
    // æˆ–è€…ä½¿ç”¨C++åŒ…è£…å™¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    // session_options.AppendExecutionProvider_CUDA(cuda_options);
}
```

### æ›´ç°ä»£çš„ç”¨æ³•ï¼ˆæ–°ç‰ˆæœ¬APIï¼‰

```cpp
// æ–°ç‰ˆæœ¬ONNX Runtimeæ¨èçš„ä½¿ç”¨æ–¹å¼
void setupCUDASessionModern() {
    Ort::SessionOptions session_options;
    
    // åˆ›å»ºå¹¶é…ç½®CUDAé€‰é¡¹
    auto cuda_options = Ort::GetApi().CreateCUDAProviderOptions();
    
    // æ›´æ–°é€‰é¡¹ï¼ˆæ–°ç‰ˆæœ¬APIï¼‰
    std::vector<const char*> keys = {"device_id", "gpu_mem_limit"};
    std::vector<const char*> values = {"0", "2147483648"}; // 2GB
    
    Ort::ThrowOnError(Ort::GetApi().UpdateCUDAProviderOptions(
        cuda_options, 
        keys.data(), 
        values.data(), 
        keys.size()
    ));
    
    // æ·»åŠ CUDAæä¾›å™¨
    Ort::ThrowOnError(Ort::GetApi().SessionOptionsAppendExecutionProvider_CUDA(
        session_options, 
        cuda_options
    ));
    
    // é‡Šæ”¾é€‰é¡¹
    Ort::GetApi().ReleaseCUDAProviderOptions(cuda_options);
}
```

### å®Œæ•´çš„åˆ†ç±»å™¨ç¤ºä¾‹

```cpp
class CIARF10Classifier {
private:
    Ort::Env env;
    std::unique_ptr<Ort::Session> session;
    
public:
    CIARF10Classifier(const std::string& model_path, bool use_gpu = false) {
        Ort::SessionOptions session_options;
        
        if (use_gpu) {
            // é…ç½®CUDA
            OrtCUDAProviderOptions cuda_options{};
            cuda_options.device_id = 0;
            cuda_options.gpu_mem_limit = 2 * 1024 * 1024 * 1024UL;
            
            Ort::ThrowOnError(OrtSessionOptionsAppendExecutionProvider_CUDA(
                session_options, 
                &cuda_options
            ));
        }
        
        // åˆ›å»ºä¼šè¯
        Ort::ThrowOnError(Ort::GetApi().CreateSession(
            env, 
            model_path.c_str(), 
            session_options, 
            &session
        ));
    }
};
```

æ³¨æ„ï¼šå…·ä½“çš„å‡½æ•°å¯ç”¨æ€§å–å†³äºä½ ä½¿ç”¨çš„ ONNX Runtime ç‰ˆæœ¬ï¼Œå»ºè®®æŸ¥çœ‹å¯¹åº”ç‰ˆæœ¬çš„æ–‡æ¡£æˆ–å¤´æ–‡ä»¶ã€‚
## å¤´æ–‡ä»¶å­¦ä¹ çš„æœ€ä½³å®è·µ

### 1. **æŒ‰åŠŸèƒ½æ¨¡å—å­¦ä¹ **
- å…ˆæŒæ¡æ ¸å¿ƒç±»ï¼ˆEnv, Session, Valueï¼‰
- å†å­¦ä¹ è¾…åŠ©ç±»ï¼ˆMemoryInfo, Allocatorï¼‰
- æœ€åäº†è§£é«˜çº§åŠŸèƒ½ï¼ˆè‡ªå®šä¹‰æ“ä½œç¬¦ç­‰ï¼‰

### 2. **ç»“åˆå®˜æ–¹æ–‡æ¡£**
- ONNX Runtime GitHubä»“åº“æœ‰è¯¦ç»†çš„APIæ–‡æ¡£
- æŸ¥çœ‹å¤´æ–‡ä»¶ä¸­çš„æ³¨é‡Šè¯´æ˜
- å‚è€ƒå®˜æ–¹ç¤ºä¾‹ä»£ç 

### 3. **ä»ç®€å•åˆ°å¤æ‚**
```cpp
// é˜¶æ®µ1ï¼šåŸºæœ¬ä½¿ç”¨
#include <onnxruntime_cxx_api.h>

// é˜¶æ®µ2ï¼šé«˜çº§åŠŸèƒ½
#include <onnxruntime_custom_op.h>  // è‡ªå®šä¹‰æ“ä½œç¬¦
```

## ç†è§£æ£€æŸ¥

è¯·æ€è€ƒä»¥ä¸‹é—®é¢˜ï¼š

1. **ä¸ºä»€ä¹ˆéœ€è¦ `Ort::Env` ç±»ï¼Ÿ**
   - æç¤ºï¼šè€ƒè™‘å…¨å±€çŠ¶æ€ç®¡ç†å’Œèµ„æºåˆå§‹åŒ–çš„å¿…è¦æ€§

2. **`SessionOptions` å’Œ `RunOptions` æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ**
   - æç¤ºï¼šä¸€ä¸ªé…ç½®ä¼šè¯æ•´ä½“è¡Œä¸ºï¼Œä¸€ä¸ªæ§åˆ¶å•æ¬¡è¿è¡Œè¡Œä¸º

3. **`Ort::Value` ç±»å¦‚ä½•å®ç°æ•°æ®ç±»å‹å®‰å…¨ï¼Ÿ**
   - æç¤ºï¼šè§‚å¯Ÿæ¨¡æ¿æ–¹æ³• `GetTensorMutableData<T>()`

4. **å†…å­˜ä¿¡æ¯åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ç‰¹åˆ«é‡è¦ï¼Ÿ**
   - æç¤ºï¼šè€ƒè™‘CPUå’ŒGPUè®¡ç®—æ—¶çš„å†…å­˜å·®å¼‚

## ğŸ’¡ å®é™…æ¢ç´¢å»ºè®®

åœ¨æ‚¨çš„å¼€å‘ç¯å¢ƒä¸­ï¼Œå¯ä»¥ï¼š

1. **æŸ¥çœ‹å¤´æ–‡ä»¶æºç **ï¼š
   ```bash
   # åœ¨ONNX Runtimeå®‰è£…ç›®å½•ä¸­
   find include/ -name "*.h" -type f
   ```

2. **ä½¿ç”¨IDEçš„ä»£ç è·³è½¬**ï¼š
   - åœ¨VSCodeä¸­æŒ‰ä½Ctrlç‚¹å‡»ç±»åï¼ŒæŸ¥çœ‹å®šä¹‰
   - ä½¿ç”¨é¼ æ ‡æ‚¬åœæŸ¥çœ‹å‡½æ•°ç­¾å

3. **ç¼–å†™æµ‹è¯•ä»£ç æ¢ç´¢**ï¼š
   ```cpp
   // å°è¯•ä¸åŒçš„é…ç½®ï¼Œè§‚å¯Ÿæ•ˆæœ
   Ort::SessionOptions options;
   options.SetIntraOpNumThreads(2);  // æ”¹ä¸º2ä¸ªçº¿ç¨‹è¯•è¯•
   ```
