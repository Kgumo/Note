### 多线程/并发处理形式  

**线程池**：是一种多线程/并发处理形式，它能够将任务添加到队列里面，并在创建线程之后自动启动这些任务。  

#### 线程池的作用：  
- **复用线程**：减少线程的创建和销毁的开销。  
  - 通过预先创建一定数量的线程并且存储在线程池中，可以避免频繁的创建和销毁操作。  
- **有效的控制线程的数量**：方便的进行线程管理，可以控制同时运行的线程数量，防止线程过多导致资源耗尽的问题。  
- **提高系统响应速度**：当有新任务的时候，不需要创建线程，立马执行。  

#### 线程池的工作原理  
- 在应用程序启动时，创建一定数量的线程存储在线程池中。  
  - 这些线程是待命状态（休眠状态）。  
- 当需要执行任务的时候，从线程池中抓取一个空闲的线程，将任务分配给该线程去执行。  
  - 当有任务存在，就随机唤醒一个线程去执行。  
- 任务执行完毕之后，线程返回到线程池中，继续待命（休眠）。  
  - 任务结束，就休眠。  

---

### 项目-线程池  
**需求**：设计一个线程池库，适用于线程并发执行任务，可以动态规划线程池内线程数目。基于 POSIX Thread 进行开发。  
**项目名**：POSIX-Thread-Pool 简称 PTP。  

#### 数据说明  
**任务类型：`task_t`**  
```c
typedef void (*task_point_t)(void *);  

// 任务结构类型  
typedef struct tasks  
{  
    // 任务指针  
    task_point_t task_point;  
    /*  
    // 任务函数需要符合这个规则  
    void task(void *data)  
    {  
        // 需要执行的任务  
    }  
    */  

    // 任务执行所需要参数  
    void *args;  

    // 下一个任务  
    struct tasks *next;  
} task_t;  
```  
- **`task_point`**：任务函数指针，即用户自定义的任务函数（线程需要去执行的任务函数指针）。  
- **`args`**：线程在执行 `task_point` 指向的任务时，需要使用到的参数。  
- **`next`**：指向下一个任务结点。  

---

**线程池类型：`ptp_t`**  
```c
typedef struct posix_thread_pool  
{  
    // 线程的个数  
    int thread_count;  

    // 线程池状态  
    bool thread_status;  

    // 线程集合  
    pthread_t *thread_id;  

    // 线程池中线程共享的互斥锁  
    pthread_mutex_t thread_mutex;  

    // 线程池中线程共享的条件变量，即通知  
    pthread_cond_t thread_cond;  

    // 线程任务链表  
    task_t *thread_tasks;  

    // 轮询任务的线程  
    pthread_t loop_task;  

    /*  
    最大线程的数目：表示可以支持线程并发的最大线程数  
    当前服役的线程数目：表示当前能够并发的线程数量  
    当前休眠的线程数目：表示当前正在待命且可以执行任务的线程数量。  
    ...  
    */  
} ptp_t;  
```  
- **`thread_count`**：线程池中最大线程数量，即能够支持的最高并发数目。  
- **`thread_status`**：线程池当前状态，启动或停止状态。  
- **`thread_id`**：线程池中服役线程集合。  
- **`thread_mutex`**：线程池中线程的共享互斥锁。  
- **`thread_cond`**：线程池中线程共享的条件变量。  
- **`thread_tasks`**：线程池中线程所需要执行的任务链表。  
- **`loop_task`**：线程池中轮询线程池任务链表的线程。  

---

### PTP 线程池的 API  
#### 初始化线程池  
初始化/创建一个线程池。  
```c
ptp_t *ptp_init(int count);  
/*  
@描述：  
创建一个线程池并初始化  
初始化：ptp_t 成员变量  
    - 'thread_count'; 线程池中最大线程数量，即能够支持的最高并发数目  
    - 'thread_status'; 线程池当前状态，启动或停止状态  
    - 'thread_id'; 线程池中服役线程集合  
    - 'thread_mutex'; 线程池中线程的共享互斥锁  
    - 'thread_cond'; 线程池中线程共享的条件变量  
    - 'thread_tasks'; 线程池中线程所需要执行的任务链表  
    - 'loop_task'; 线程池中轮询线程池任务链表的线程  

@count：  
设置线程池中最大服役/并发线程数量  
@return：  
成功返回创建并初始化完毕的线程池指针  
失败返回NULL  
*/  
```  

#### 销毁线程池  
销毁一个存在的线程池。  
```c
void ptp_destroy(ptp_t *&thread_pool);  
/*  
@描述：  
销毁一个已经存在线程池  
@thread_pool：  
需要销毁的线程池指针引用  
*/  
```  

#### 添加任务  
往一个已存在的线程池中增加任务。  
```c
void ptp_add_task(ptp_t *thread_pool, task_point_t task, void *args);  
/*  
@描述：  
往一个已存在的线程池中增加任务  
@thread_pool：  
需要增加任务的线程池指针  
@task：  
增加的任务函数指针  
@args：  
任务函数执行过程中需要的参数  
*/  
```  

#### 判断线程池的任务是否为空  
判断指定的线程池任务链表是否为空。  
```c
bool ptp_task_is_null(ptp_t *thread_pool);  
/*  
    @描述：  
    用于判断指定的线程池任务链表是否为空  
    @thread_pool:  
    需要判断任务链表是否为空的线程池指针  
    @return:  
    不为空返回false，为空返回true  
*/  
```  

---

### 作业：  
1. 弄清楚线程池代码。  
2. 复刻一下线程池。